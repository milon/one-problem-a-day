[{"title":"Lowest\u00a0common\u00a0ancestor\u00a0of\u00a0a\u00a0binary tree\u00a0IV","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lowest-common-ancestor-of-a-binary-tree-iv","snippet":"We will use a recursive approach to solve this problem. We will traverse the tree in a post-order fashion. We will return the node if it is equal to any of the nodes in the list of nodes. We will return <code>None<\/code> if the node is <code>None<\/code>...."},{"title":"Split\u00a0strings\u00a0by\u00a0separator","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/split-strings-by-separator","snippet":"We will iterate over the words and split them by the separator. We will then append the non-empty words to the result list.\n\n\n\nTime Complexity: <code>O(n)<\/code> where <code>n<\/code> is the number of words. \nSpace Complexity: <code>O(n)<\/code> where..."},{"title":"Number\u00a0of\u00a0increasing\u00a0paths\u00a0in\u00a0a\u00a0grid","categories":["dynamic-programming","graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-increasing-paths-in-a-grid","snippet":"We will start DFS from the top left corner of the grid and keep track of the number of paths that we have found so far. We will also keep track of the number of paths that we have found so far for each cell in the grid. If we have already found the..."},{"title":"Missing\u00a0ranges","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/missing-ranges","snippet":"We will add 2 numbers to the existing array <code>lower-1<\/code> and <code>upper+1<\/code> which will be the lower and upper bound of the range to avoid edge cases. Then we will iterate over the array and check if the difference between the current number..."},{"title":"Check\u00a0if\u00a0all\u00a0characters\u00a0have\u00a0equal\u00a0number\u00a0of\u00a0occurrences","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-all-characters-have-equal-number-of-occurrences","snippet":"We will count all the occurance of the characters in the string and store it in a hashmap. Then we will check if all the values in the hashmap are equal or not.\n\n\n\nTime Complexity: <code>O(n)<\/code> where <code>n<\/code> is the length of the string...."},{"title":"Summary\u00a0ranges","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/summary-ranges","snippet":"We will iterate over the array and find the ranges. Then we will map the ranges to the required format.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0value\u00a0at\u00a0a\u00a0given\u00a0index\u00a0in\u00a0a\u00a0bounded\u00a0array","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-value-at-a-given-index-in-a-bounded-array","snippet":"We can use binary search to find the maximum value at a given index in a bounded array. We can use the formula for the sum of an arithmetic series to find the maximum value at a given index. The formula is <code>n * (n+1) \/\/ 2<\/code>. We can use this..."},{"title":"Check\u00a0if\u00a0a\u00a0number\u00a0is\u00a0majority\u00a0element\u00a0in\u00a0a\u00a0sorted\u00a0array","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-a-number-is-majority-element-in-a-sorted-array","snippet":"We can just count the number of times <code>target<\/code> appears in <code>nums<\/code>. If it appears more than <code>len(nums)\/\/2<\/code> times, then it is the majority element.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>..."},{"title":"Count\u00a0negative\u00a0numbers\u00a0in\u00a0a\u00a0sorted\u00a0matrix","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-negative-numbers-in-a-sorted-matrix","snippet":"We will iterate through each row and count the number of negative numbers in each row. We will add the count to the total count.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Can\u00a0make\u00a0arithmetic\u00a0progression\u00a0from sequence","categories":["math-and-geometry","array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/can-make-arithmetic-progression-from-sequence","snippet":"We will sort the array and then check if the difference between each element is the same.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Check\u00a0if\u00a0it\u00a0is\u00a0a\u00a0straight\u00a0line","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-it-is-a-straight-line","snippet":"We will check if the slope of the line joining the first two points is equal to the slope of the line joining the second and third points. If it is, then we will check the same for the next two points and so on.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Time\u00a0needed\u00a0to\u00a0inform\u00a0all\u00a0employees","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/time-needed-to-inform-all-employees","snippet":"We will start BFS from the manager with no manager. We will keep track of the maximum time taken to inform all the employees.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Shortest\u00a0path\u00a0in\u00a0binary\u00a0matrix","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-path-in-binary-matrix","snippet":"We will start BFS from the top left corner of the matrix till we reach the bottom right. Then we will return the shortest path length.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Number\u00a0of\u00a0substrings\u00a0containing\u00a0all\u00a0three\u00a0characters","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-substrings-containing-all-three-characters","snippet":"We can use a sliding window to solve the problem. We will use a variable <code>count<\/code> to store the number of substrings containing all three characters. Then we will iterate over the string and update <code>count<\/code> accordingly. Finally, we..."},{"title":"Vowels of all substrings","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/vowels-of-all-substrings","snippet":"We can use bottom-up dynamic programming to solve the problem. We will use a variable <code>vowels<\/code> to store the number of vowels in the string. Then we will iterate over the string and update <code>vowels<\/code> accordingly. Finally, we will..."},{"title":"Stone game\u00a0II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stone-game-ii","snippet":"We can use top-down dynamic programming to solve the problem. First we will calculate the suffix sum of the piles. Then we will use two pointers <code>i<\/code> and <code>m<\/code> to iterate over the piles and the number of stones that can be taken..."},{"title":"Stone game\u00a0III","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stone-game-iii","snippet":"We can use top-down dynamic programming to solve the problem. We will use two pointers <code>i<\/code> and <code>m<\/code> to iterate over the piles and the number of stones that can be taken respectively. If <code>i &gt;= n<\/code>, we will return 0...."},{"title":"Univalued\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/univalued-binary-tree","snippet":"We can use depth-first search to solve the problem. We will use a variable <code>val<\/code> to store the value of the root node. Then we will recursively check if the value of the current node is equal to <code>val<\/code>. If it is not, we will return..."},{"title":"Count\u00a0vowel\u00a0strings\u00a0in\u00a0ranges","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-vowel-strings-in-ranges","snippet":"We construct alambdaboolean functionvowelsto assess whether the word qualifies. Then we map the words using this function. Then we construct the prefix sum of the mapped words. Finally, we return the difference between the prefix sum of the end and the..."},{"title":"Left\u00a0and\u00a0right\u00a0sum\u00a0differences","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/left-and-right-sum-differences","snippet":"We will iterate over the array and compute the sum of the left and right subarrays as we iterate through. Then we will compute the difference between the sums and append it to our result. Finally we return our result.\n\n\n\nTime complexity:..."},{"title":"Maximum\u00a0subsequence\u00a0score","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-subsequence-score","snippet":"We can use a heap to store the elements in the array. Then, we can pop the elements from the heap and add them to the result. We will also keep track of the sum of the elements in the heap. If the sum is greater than the result, we will update the..."},{"title":"Sum\u00a0in\u00a0a\u00a0matrix","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-in-a-matrix","snippet":"We will iterate over each row and sort them. Then we iterate over each column and get the maximum value of the column. Finally, we return the sum of the maximum values.\n\n\n\nTime complexity: <code>O(nmlog(m))<\/code> where n is the number of rows and m is..."},{"title":"Find\u00a0three\u00a0consecutive\u00a0integers\u00a0that\u00a0sum\u00a0to\u00a0a\u00a0given\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-three-consecutive-integers-that-sum-to-a-given-number","snippet":"We will check whether the number is divisible by 3. If it is, we can return the three consecutive numbers. Otherwise, we will return empty arry.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Split\u00a0a\u00a0circular\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/split-a-circular-linked-list","snippet":"We can use a slow and fast pointer to find the middle of the linked list. Then, we can set the next pointer of the last node to <code>None<\/code> to split the linked list into two. We can then return the head of the second linked list.\n\n\n\nTime..."},{"title":"Kth\u00a0largest\u00a0sum\u00a0in\u00a0a\u00a0binary\u00a0tree","categories":["heap","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-largest-sum-in-a-binary-tree","snippet":"We will traverse the whole tree with BFS and store each levels sum in a list. Then, we will use a heap to get the <code>k<\/code>-th largest sum. We will also check if the tree doesn't have enough levels to reach k, then we return -1.\n\n\n\nTime complexity:..."},{"title":"K-th\u00a0smallest\u00a0prime\u00a0fraction","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/k-th-smallest-prime-fraction","snippet":"We can use a heap to store the fractions. We can start with the fraction <code>1\/n<\/code> and add the next smallest fraction to the heap. We can repeat this process until we have added <code>k<\/code> fractions to the heap. The last fraction in the heap..."},{"title":"Maximum\u00a0profit\u00a0from\u00a0trading\u00a0stocks","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-profit-from-trading-stocks","snippet":"This is a classic 0-1 knapsack problem. We can use dynamic programming to solve this problem. We can iterate through the prices array and calculate the maximum profit for each day. The maximum profit for each day is the maximum of the maximum profit for..."},{"title":"Check\u00a0if\u00a0word\u00a0equals\u00a0summation\u00a0of\u00a0two\u00a0words","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-word-equals-summation-of-two-words","snippet":"We can convert the words to integers and check if the sum of the first two integers equals the third integer.\n\n\n\nTime complexity: <code>O(n)<\/code> where n is the length of the longest word.\nSpace complexity: <code>O(1)<\/code>\n\nWe can also achieve the..."},{"title":"The\u00a0kth\u00a0factor\u00a0of\u00a0n","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/the-kth-factor-of-n","snippet":"We can iterate through the numbers from 1 to n and check if the number is a factor of n. If it is, we decrement k by 1. If k is 0, we return the number.\n\n\n\nTime complexity: <code>O(n)<\/code> where n is the value of n. \nSpace complexity: <code>O(1)<\/code>"},{"title":"Number\u00a0of\u00a0adjacent\u00a0elements\u00a0with\u00a0the\u00a0same\u00a0color","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-adjacent-elements-with-the-same-color","snippet":"We can use a hashmap to store the indices of each color. Then, we can iterate through the array and check if the adjacent elements have the same color.\n\n\n\nTime complexity: <code>O(n)<\/code> where n is the length of the queries array. \nSpace complexity:..."},{"title":"Diameter\u00a0of\u00a0N-ary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/diameter-of-n-ary-tree","snippet":"We will use recursive DFS to find out the longest path in the tree. The longest path will be the diameter of the tree.\n\n\n\nTime complexity: <code>O(n)<\/code> where n is the number of nodes in the tree. \nSpace complexity: <code>O(h)<\/code> where h is the..."},{"title":"Number\u00a0of\u00a0good\u00a0leaf\u00a0nodes\u00a0pairs","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-good-leaf-nodes-pairs","snippet":"We can traverse the tree and find out the distance between each pair of leaf nodes. If the distance is less than or equal to the given distance, we increment the result by 1.\n\n\n\nTime complexity: <code>O(n^2)<\/code> where n is the number of nodes in the..."},{"title":"Remove\u00a0sub\u00a0folders\u00a0from\u00a0the\u00a0filesystem","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-sub-folders-from-the-filesystem","snippet":"We can use a trie data structure to store all the folders. We will iterate over the folders and insert them into the trie. If we find a folder that is already present in the trie, we will mark it as a duplicate. We will return all the folders that are..."},{"title":"Consecutive\u00a0characters","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/consecutive-characters","snippet":"We will keep track of the consecutive characters in a variable <code>count<\/code>. We will iterate over the string and if the current character is same as the previous character, we will increment the <code>count<\/code> variable. Otherwise, we will reset..."},{"title":"Count\u00a0triplets\u00a0that\u00a0can\u00a0form\u00a0two\u00a0arrays\u00a0of\u00a0equal\u00a0xor","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-triplets-that-can-form-two-arrays-of-equal-xor","snippet":"We will calculate the prefix xor for each index. Then we will iterate over all possible pairs of indices and check if the xor of the prefix xors of the two indices is 0. If it is, we will increment the result by 1. Finally, we will return the result...."},{"title":"Make\u00a0array\u00a0zero\u00a0by\u00a0subtracting\u00a0equal\u00a0amounts","categories":["heap","math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/make-array-zero-by-subtracting-equal-amounts","snippet":"We can solve this problem by using a heap. We will add all the elements to the heap. Then we will pop the largest element from the heap and substruct it from all the other elements. We will repeat this process until all the elements are equal. Finally,..."},{"title":"Maximum\u00a0product\u00a0of\u00a0two\u00a0elements\u00a0in\u00a0an\u00a0array","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-product-of-two-elements-in-an-array","snippet":"We will use a heap to get the two largest elements in the array. Then we will return the product of the two largest elements each substructed by 1.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>\n\nWe can use..."},{"title":"Android\u00a0unlock\u00a0patterns","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/android-unlock-patterns","snippet":"We can use backtracking to solve the problem. We will start from the first number and try to find all possible patterns. We will use a hashmap to store the numbers that are already used. Now we will try to find all possible patterns starting with the..."},{"title":"Count\u00a0ways\u00a0to build good\u00a0strings","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-ways-to-build-good-strings","snippet":"All we care about is low and high. We subtruct from high number of zeros or number of ones if can. Same we do for low but max it with 0. If we reached 0 in low than we add one to the answer.\n\n\n\nTime complexity: <code>O(n)<\/code> where <code>n<\/code> is..."},{"title":"Find\u00a0permutation","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-permutation","snippet":"Loop on the input and insert a decreasing numbers when see a 'I'. Or insert a decreasing numbers to complete the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Letter\u00a0tile\u00a0possibilities","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/letter-tile-possibilities","snippet":"We will use DFS to generate all possible strings. We will generate all the strings, put it in a set for remove duplication and finally return the count as the result.\n\n\n\nTime complexity: <code>O(n!)<\/code> \nSpace complexity: <code>O(n!)<\/code>"},{"title":"Maximum\u00a0length\u00a0of\u00a0subarray\u00a0with\u00a0positive\u00a0product","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-length-of-subarray-with-positive-product","snippet":"We can use top-down dynamic programming to solve the problem. We will start from index 0, and move forward. If the current element is positive, we will increment the result by 1 and move forward. If the current element is 0, we will reset the result to..."},{"title":"Solving\u00a0questions\u00a0with\u00a0brainpower","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/solving-questions-with-brainpower","snippet":"We will start from index 0, then either take the current element or skip it. If we take the current element, we will move forward to the next element. If we skip the current element, we will move forward to the next element. We will use a hashmap to..."},{"title":"Equal\u00a0tree\u00a0partition","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/equal-tree-partition","snippet":"Cutting an edge means cutting off a proper subtree (i.e., a subtree but not the whole tree). I collect the sums of these proper subtrees in a set and check whether half the total tree sum is a possible cut.\n\n\n\nTime complexity: <code>O(n)<\/code>, where..."},{"title":"Largest\u00a0unique\u00a0number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-unique-number","snippet":"We will use a hashmap to store the frequency of each number. Then we will iterate over the hashmap and return the maximum number whose frequency is 1. If there is no such number, we will return -1.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Uncrossed\u00a0lines","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/uncrossed-lines","snippet":"We can use top-down dynamic programming to solve the problem. We will use two pointers <code>i<\/code> and <code>j<\/code> to iterate over <code>A<\/code> and <code>B<\/code> respectively. If A[i] == B[j], we will increment both <code>i<\/code> and..."},{"title":"Increasing\u00a0order\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/increasing-order-search-tree","snippet":"We can just do an inorder traversal and keep track of the previous node. Then we will set the left child of the current node to <code>None<\/code> and the right child to the previous node. Finally, we will return the root node.\n\n\n\nTime complexity:..."},{"title":"Prime\u00a0in\u00a0diagonal","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/prime-in-diagonal","snippet":"We will start our initial result with 0. Then we will iterate over the matrix and check if the current diagonal element is a prime number. If it is, we will keep the maximum between current result and the diagonal element as result. Finally, we will..."},{"title":"Valid\u00a0boomerang","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-boomerang","snippet":"We will calculate the slope of the line between the first and second point and the slope of the line between the first and third point. If the slope of the first and second point is the same as the slope of the first and third point, then the three..."},{"title":"Matrix\u00a0diagonal\u00a0sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/matrix-diagonal-sum","snippet":"We will traverse the matrix row by row. For each row, we have to take 2 diagonal position and add it to the result. If the matrix has an odd number of rows, we have to subtract the middle element from the result. Finally, we will return the result...."},{"title":"Sort\u00a0array\u00a0by\u00a0increasing\u00a0frequency","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-array-by-increasing-frequency","snippet":"We will use a hashmap to store the frequency of each number. Then we will sort the array by the frequency of each number. If the frequency of two numbers is the same, we will sort them by the value of the number. Finally, we will return the sorted..."},{"title":"Concatenation\u00a0of\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/concatenation-of-array","snippet":"We can just merge the array with itself and return.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Find\u00a0score\u00a0of\u00a0an\u00a0array\u00a0after\u00a0marking\u00a0all\u00a0elements","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-score-of-an-array-after-marking-all-elements","snippet":"We will use a heap to store the elements. We will pop the maximum element from the heap and mark it. Then we will push the maximum element divided by 2 back to the heap. We will repeat this process until the heap is empty.\n\n\n\nTime complexity:..."},{"title":"Find\u00a0the\u00a0longest\u00a0valid\u00a0obstacle\u00a0course\u00a0at\u00a0each\u00a0position","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-longest-valid-obstacle-course-at-each-position","snippet":"Given an array of integers, find the longest non-decreasing subsequence. This problem is very similar to Longest increasing subsequence. We will solve this with a greedy approach. The key is, the longest course for index i is determined by two factors:..."},{"title":"Maximum\u00a0number\u00a0of\u00a0vowels\u00a0in\u00a0a\u00a0substring\u00a0of\u00a0given\u00a0length","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-vowels-in-a-substring-of-given-length","snippet":"We will first count the number of vowels in the whole string. Then we will use a sliding window to find the maximum number of vowels in a substring of given length. We will return the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Substrings\u00a0that\u00a0begin\u00a0and\u00a0end\u00a0with\u00a0the\u00a0same\u00a0letter","categories":["array-and-hashmap","math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/substrings-that-begin-and-end-with-the-same-letter","snippet":"Traverse from left to right, when visiting a character C, number of substring that begin and end with C in the prefix substring is the frequency of C (in this prefix substring)+1.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Index\u00a0pairs\u00a0of\u00a0a\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/index-pairs-of-a-string","snippet":"We will first create a set of all the words in <code>words<\/code>. Then, we will iterate through <code>text<\/code> and check if the current word is in the set. If it is, we will add the current index and the current index plus the length of the current..."},{"title":"Maximum\u00a0sum\u00a0with\u00a0exactly\u00a0k\u00a0elements","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-sum-with-exactly-k-elements","snippet":"We will pick up the maximum number and add it to the result. Then for each iteration of k, we add 1 to the maximum number and add it to the result. We will return the result.\n\n\n\nTime complexity: <code>O(k)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Greatest\u00a0common\u00a0divisor\u00a0of\u00a0strings","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/greatest-common-divisor-of-strings","snippet":"We will check if the length of <code>str1<\/code> is divisible by the length of <code>str2<\/code>. If it is, we will check if <code>str1<\/code> is equal to <code>str2<\/code> multiplied by the length of <code>str1<\/code> divided by the length of..."},{"title":"Sentence\u00a0similarity","categories":["array-and-hashmap","graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sentence-similarity","snippet":"The bruteforce way is to everytime when you see a word in sentence2, you loop through the entire similarPairs, see if the word exisits in one of the paris together with the corresponding word in sentence1. This is linear time for the check and to check..."},{"title":"Best\u00a0team\u00a0with\u00a0no\u00a0conflicts","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-team-with-no-conflicts","snippet":"We will sort the players by their score, and then we will iterate over the players and for each player we will find the best team that can be formed by including the current player. We will use a dynamic programming approach to solve this problem. We..."},{"title":"Game\u00a0of\u00a0nim","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/game-of-nim","snippet":"We will calculate the XOR sum of all the piles, and check whether it's zero or not. For non zero value player 1 wins, otherwise player 2 wins.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"LFU\u00a0cache","categories":["linked-list","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lfu-cache","snippet":"We will create a hashmap to store the key-value pairs and a doubly linked list to maintain the frequency of each key. When a key is accessed, check if it exists in the hashmap. If it does, update its value and increment its frequency. If the key does not..."},{"title":"Data\u00a0stream\u00a0as\u00a0disjoint\u00a0intervals","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/data-stream-as-disjoint-intervals","snippet":"We will construct the interval by expanding around each of the added numbers.\n\n\n\nTime complexity: <code>O(n)<\/code> for getIntervals, <code>O(1)<\/code> for addNum \nSpace complexity: <code>O(n)<\/code>"},{"title":"Concatenated\u00a0words","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/concatenated-words","snippet":"We can use the Trie data structure trie to store the words. Then for each word in the list of words, we use depth first search to see whether it is a concatenation of two or more words from the list. We first build a trie structure that stores the list..."},{"title":"Find\u00a0closest\u00a0node\u00a0to\u00a0given\u00a0two\u00a0nodes","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-closest-node-to-given-two-nodes","snippet":"We will calculate distances between node1 and other reachable nodes. Then we will do the same thing for node2 too. Then we will iterate the nodes that are on the path for both distances and find max. Then find min of maxes and keep track of minimum..."},{"title":"Find\u00a0minimum\u00a0time\u00a0to\u00a0finish\u00a0all\u00a0jobs II","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-minimum-time-to-finish-all-jobs-ii","snippet":"We can be greedy about the solution. We will sort all the workers and jobs, then iterate together to find the minimum time. We will start with the biggest worker and the biggest job. If the worker can do the job, we will assign it to him and move to the..."},{"title":"Queue\u00a0reconstruction\u00a0by\u00a0height","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/queue-reconstruction-by-height","snippet":"We can sort people by their height in descending order and if heights are equal, by the number of people in front of them in ascending order. Then we can insert each person into the result array at the index equal to the number of people in front of..."},{"title":"Confusing number\u00a0II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/confusing-number-ii","snippet":"We can use backtracking to generate all possible numbers and check if they are confusing. We can generate all numbers with length from 1 to 9. For each length we can generate all numbers with digits from 1 to 9. For each number we can check if it is..."},{"title":"Candy","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/candy","snippet":"Go from left to right and while increase, give the the next person +1 candy from previous, if not, leave number of candies as it was. In this way when we make this pass we make sure that condition that person with bigger value gets more candies fulfilled..."},{"title":"Subarray\u00a0sums\u00a0divisible\u00a0by\u00a0k","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/subarray-sums-divisible-by-k","snippet":"We are using the prefix sum and the remainder of the sum divided by k to solve this problem. The idea is that if the remainder of the sum of the subarray is the same, then the sum of the subarray is divisible by k. For example, if the sum of the subarray..."},{"title":"Count\u00a0the\u00a0number\u00a0of\u00a0good\u00a0subarray","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-the-number-of-good-subarray","snippet":"We will use a sliding window to count the number of good subarray.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of the array. \nSpace complexity: <code>O(n)<\/code>"},{"title":"Find\u00a0the\u00a0celebrity","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-celebrity","snippet":"First we need to find the celebraty candidate. We will take two pointers, left and right must meet at some point, this person is a potential celebrity. Next we need verify if the candidate is indeed a celebrity, there are 2 scenarios:\n\n\nAt least one..."},{"title":"Flip\u00a0string to\u00a0monotone\u00a0increasing","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flip-string-to-monotone-increasing","snippet":"A string of <code>'0'<\/code>s and <code>'1'<\/code>s is monotone increasing if it consists of some number of <code>'0'<\/code>s (possibly 0), followed by some number of <code>'1'<\/code>s (also possibly 0.)\n\n\nSo we iterate throughs, but for all0before the..."},{"title":"Minimum\u00a0moves\u00a0to\u00a0reach\u00a0target\u00a0score","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-moves-to-reach-target-score","snippet":"We should use double action as late as possible, as many times as possible. We can use a greedy approach to solve this problem.\n\n\n\nTime complexity: <code>O(log(n))<\/code>, n is the target. \nSpace complexity: <code>O(1)<\/code>"},{"title":"Percentage\u00a0of\u00a0letter\u00a0in\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/percentage-of-letter-in-string","snippet":"We will count the number of occurance of the letter in the string, and then calculate the percentage of the given letter.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of the string. \nSpace complexity: <code>O(1)<\/code>"},{"title":"Difference\u00a0between\u00a0element\u00a0sum\u00a0and\u00a0digit\u00a0sum\u00a0of\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/difference-between-element-sum-and-digit-sum-of-an-array","snippet":"We will calculate the sum of every digit in the array and subtract it from the sum of the array.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>\n\nWe can achieve the same result with a single line."},{"title":"Find\u00a0the\u00a0index\u00a0of\u00a0the\u00a0large\u00a0integer","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-index-of-the-large-integer","snippet":"We will use binary search to find the index of the large integer.\n\n\n\nTime complexity: <code>O(log(n))<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Number\u00a0of\u00a0good paths","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-good-paths","snippet":"We will try to build the graph from nodes with the smallest value to the largest value. If we build the graph in this way, nodes in the graph will always be smaller than or equal to the value we are checking, then we just need to calculate nCr for each..."},{"title":"Lexicographically smallest equivalent string","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lexicographically-smallest-equivalent-string","snippet":"We will use basic union-find to find the equivalence classes. Then we will create a new string by iterating over the string <code>A<\/code> and replacing each character with the smallest character in its equivalence class.\n\n\n\nTime complexity:..."},{"title":"Longest\u00a0path\u00a0with\u00a0different\u00a0adjacent\u00a0characters","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-path-with-different-adjacent-characters","snippet":"We will create a tree from the edges list. Then we will start DFS from starting node <code>0<\/code>. Then we will calculate the longest path in the subtree of each node. Finally we will return the longest path in the subtree of each node.\n\n\n\nTime..."},{"title":"Number\u00a0of\u00a0good\u00a0binary\u00a0strings","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-good-binary-strings","snippet":"We will solve it using top-down dynamic programming. We will create a helper function dp that will return the number of good binary strings of length <code>n<\/code> and ending with <code>end<\/code>. Then we will return the number of good binary strings..."},{"title":"Number\u00a0of\u00a0nodes\u00a0in\u00a0the\u00a0sub\u00a0tree\u00a0with\u00a0the\u00a0same\u00a0label","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-nodes-in-the-sub-tree-with-the-same-label","snippet":"We will create a tree from the edges list. Then we will start DFS from starting node <code>0<\/code>. Then we will calculate all the nodes in the subtree of each node. Finally we will return the number of nodes in the subtree of each node.\n\n\n\nTime..."},{"title":"Maximum\u00a0binary\u00a0string\u00a0after\u00a0change","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-binary-string-after-change","snippet":"We will use greedy approach to solve the problem. We will find the first <code>0<\/code> and change it to <code>1<\/code>. Then we will find the next <code>0<\/code> and change it to <code>1<\/code>. We will repeat this process until we find the last..."},{"title":"Maximum\u00a0number\u00a0of\u00a0points\u00a0with\u00a0cost","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-points-with-cost","snippet":"We will use top-down approach to solve the problem. We will calculate the maximum points for each cell. Then we will return the maximum points in the last row.\n\n\n\nTime complexity: <code>O(mn)<\/code> \nSpace complexity: <code>O(mn)<\/code>"},{"title":"Minimum\u00a0time\u00a0to\u00a0collect\u00a0all\u00a0apples\u00a0in\u00a0a\u00a0tree","categories":["tree","graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-time-to-collect-all-apples-in-a-tree","snippet":"We will create a graph form the edges. Then we will start from node 0, and run DFS to visit all the apples and count the number of edges on the way. Finally we will return the maximum number of edges.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Find\u00a0good\u00a0days\u00a0to\u00a0rob\u00a0the\u00a0bank","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-good-days-to-rob-the-bank","snippet":"We will calculate the prefix sum and postfix sum of the securities. Then we iterate form time till securities-time, check the prefix and postfix sum for the given condition, if the satify, we add them to the result.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Shuffle\u00a0the\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shuffle-the-array","snippet":"We will iterate over the half of of the array and add the elements to the result array form the front and middle.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Confusing number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/confusing-number","snippet":"We will use a dictionary to map the digits to their confusing digits. We will iterate through the digits of the number and check if the confusing digit is the same as the original digit. If it is, we will return <code>False<\/code>. If it is not, we will..."},{"title":"Find\u00a0and\u00a0replace\u00a0in\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-and-replace-in-string","snippet":"We will initialize the string as a character array. Then create a replacement map using the provided source, indices and target. Then we iterate over this map, and replace the characters. Finally join together the replaced characters to create the string..."},{"title":"Maximal\u00a0score\u00a0after\u00a0applying\u00a0k\u00a0operations","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximal-score-after-applying-k-operations","snippet":"We will use a heap to keep track of the maximum score. We will pop the maximum score from the heap and apply the operations to the popped score. We will push the new scores to the heap. We will repeat this process until we have applied all the..."},{"title":"Find\u00a0xor\u00a0beauty\u00a0of\u00a0array","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-xor-beauty-of-array","snippet":"First, note that by symmetry of i and j, we know that the value of ((nums[i] | nums[j]) &amp; nums[k]) and ((nums[j] | nums[i]) &amp; nums[k]) are equal. Which then implies that for a pair of (i, j) where i != j, the bitwise XOR of ((nums[i] | nums[j])..."},{"title":"Max\u00a0points\u00a0on\u00a0a\u00a0line","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-points-on-a-line","snippet":"We will calculate the slope of each pair of points. If the slope is the same, we will increase the count. If the slope is different, we will update the maximum count.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Minimum\u00a0health\u00a0to\u00a0beat\u00a0game","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-health-to-beat-game","snippet":"Without considering the armor, we need 1 + total_damage amount of health to pass.\n\nConsidering the armor, we just use it to shield the most severe damage, call it max_damage, and it should save us min(armor, max_damage) amount of health. For example,..."},{"title":"Assign\u00a0cookies","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/assign-cookies","snippet":"We will sort both child and cookies. Then we will try to satisfy the child with the smallest greed factor. If the cookie is not enough, we will move to the next cookie. If the cookie is enough, we will move to the next child. If we have no more cookies,..."},{"title":"Max\u00a0increase\u00a0to\u00a0keep\u00a0city\u00a0skyline","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-increase-to-keep-city-skyline","snippet":"For grid[i][j], it can't be higher than the maximun of its row nor the maximum of its column. So the maximum increasing height for a building at (i, j) is <code>min(row[i], col[j]) - grid[i][j]<\/code>.\n\nrows: maximum for every row, cols: maximum for..."},{"title":"Maximum\u00a0ice\u00a0cream\u00a0bars","categories":["greedy","heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-ice-cream-bars","snippet":"We will sort the input <code>costs<\/code> array, then iterate the array, if the current cost is less than <code>coins<\/code>, we will update <code>coins<\/code> to be <code>coins-costs[i]<\/code>, and increment <code>res<\/code> by 1.\n\n\n\nTime complexity:..."},{"title":"Minimum\u00a0operations\u00a0to\u00a0make\u00a0the\u00a0array\u00a0alternating","categories":["greedy","array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-operations-to-make-the-array-alternating","snippet":"We count all the elements of odd and even positions separately and take most common 2 numbers from each group. If there is no common number, we will take the most common number from each group. Then we will count the number of operations needed to make..."},{"title":"Most\u00a0profit\u00a0assigning\u00a0work","categories":["greedy","two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/most-profit-assigning-work","snippet":"We will zip together difficulty and profit as jobs and sort them by difficulty. Then we will sort workers. For each worker, we will find the maximum profit he can make under his ability. The maximum profit he can make is the maximum profit of the job..."},{"title":"Number\u00a0of\u00a0segments\u00a0in\u00a0a\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-segments-in-a-string","snippet":"We will split the string by space, then count the number of non-empty string.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Steps\u00a0to\u00a0make\u00a0array\u00a0non\u00a0decreasing","categories":["stack","dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/steps-to-make-array-non-decreasing","snippet":"Iterating the input A backward, then for each <code>nums[i]<\/code>, find how many round it can eat on its right. <code>dp[i]<\/code> means the number of element <code>nums[i]<\/code> can eat on its right. More precisely, the number of rounds for an element..."},{"title":"Check\u00a0if\u00a0number\u00a0is\u00a0a\u00a0sum\u00a0of\u00a0powers\u00a0of\u00a0three","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-number-is-a-sum-of-powers-of-three","snippet":"We will divide the number by 3 until it becomes 0. If the remainder is 1, then we add 1 to the result. Otherwise, we add 0 to the result.\n\n\n\nTime complexity: <code>O(log(n))<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Check\u00a0if\u00a0there\u00a0is\u00a0a\u00a0valid\u00a0path\u00a0in\u00a0a\u00a0grid","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-there-is-a-valid-path-in-a-grid","snippet":"We will use BFS from the top-left cell towards bottom-right cell. If we reach the bottom-right cell, then we return <code>True<\/code>. Otherwise, we return <code>False<\/code>.\n\n\n\nTime complexity: <code>O(mn)<\/code> \nSpace complexity: <code>O(mn)<\/code>"},{"title":"Convert\u00a0to\u00a0base\u00a0-2","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-to-base-2","snippet":"We will use the following formula to convert a number <code>n<\/code> to base <code>-2<\/code>, where <code>n<\/code> is a non-negative integer-\n- Write a base 2 function\n- If the number is odd, add 1 to the result\n- Divide the number by 2\n\n\n\nTime..."},{"title":"Delete\u00a0columns\u00a0to\u00a0make\u00a0sorted","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-columns-to-make-sorted","snippet":"We will iterate over the columns and for each column we will check if the column is sorted. If it is not, we will increment the number of columns to delete. Finally, we will return the number of columns to delete.\n\n\n\nTime complexity: <code>O(nm)<\/code>..."},{"title":"Finding\u00a0the\u00a0number\u00a0of\u00a0visible\u00a0mountains","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/finding-the-number-of-visible-mountains","snippet":"We will use a monotonic stack to keep track of the mountains that are visible. We will iterate over the mountains and for each mountain we will pop the stack until the top of the stack is smaller than the current mountain. Then, we will push the current..."},{"title":"Car\u00a0pooling","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/car-pooling","snippet":"We will sort the trips by the starting point. Then we will iterate over the trips and for each trip we will add the number of passengers to the current number of passengers. If the current number of passengers is greater than the capacity, we will return..."},{"title":"Divide\u00a0intervals\u00a0into\u00a0minimum\u00a0number\u00a0of\u00a0groups","categories":["heap","intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/divide-intervals-into-minimum-number-of-groups","snippet":"We will sort the intervals by the end point. Then we will iterate over the intervals and for each interval we will check if the start point is greater than the end point of the last interval in the heap. If it is, we will pop the last interval from the..."},{"title":"K highest\u00a0ranked\u00a0items\u00a0within\u00a0a\u00a0price\u00a0range","categories":["heap","graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/k-highest-ranked-items-within-a-price-range","snippet":"We will use a heap to store the top <code>k<\/code> items. We will iterate over the items and for each item we will check if the price is within the price range. If it is, we will check if the heap size is less than <code>k<\/code>. If it is, we will push..."},{"title":"Count\u00a0the\u00a0digits\u00a0that\u00a0divide\u00a0a\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-the-digits-that-divide-a-number","snippet":"We will iterate over each digit and check if it is a divisor of the number. If it is, we will increment the counter.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Count\u00a0the\u00a0number\u00a0of\u00a0k\u00a0big\u00a0indices","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-the-number-of-k-big-indices","snippet":"We will use binary search twice, one from left, one from right to find out how many elements are less than the current element.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Distinct\u00a0prime\u00a0factors\u00a0of\u00a0product\u00a0of\u00a0array","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/distinct-prime-factors-of-product-of-array","snippet":"First we calculate all the prime numbers up to <code>n<\/code> using the Sieve of Eratosthenes. Then we iterate over the array and for each element we will increment the counter for each prime factor of the element. Finally, we will iterate over the..."},{"title":"Sum\u00a0of\u00a0all\u00a0odd\u00a0length\u00a0subarrays","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-all-odd-length-subarrays","snippet":"We will generate all possible subarrays of odd length and sum them.\n\n\n\nTime complexity: <code>O(n^3)<\/code> \nSpace complexity: <code>O(1)<\/code>\n\nWe can do this in one line too-"},{"title":"Two\u00a0sum\u00a0bsts","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/two-sum-bsts","snippet":"We will traverse the tree and store the values in a set. Then we will iterate over the set and check if <code>target - num<\/code> is in the set.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Create\u00a0binary\u00a0tree\u00a0from\u00a0descriptions","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/create-binary-tree-from-descriptions","snippet":"We will use a dictionary to store the nodes. We will iterate over the descriptions and for each description we will create a node and store it in the dictionary. Then we will iterate over the descriptions again and for each description we will check if..."},{"title":"Sum\u00a0of\u00a0all\u00a0subset\u00a0xor\u00a0totals","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-all-subset-xor-totals","snippet":"We will use backtracking to solve this problem. We will start from the first element and then we will add it to the current subset and then we will call the function again with the next element. Then we will remove the current element from the subset and..."},{"title":"Unique paths III","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-paths-iii","snippet":"We first find the start squar and end square and path length which contains all squares except the blocked. Then we start the dfs from the start node to wards the end node. And we add the node to a viseted set. Then the next nodes are..."},{"title":"3sum\u00a0smaller","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/3sum-smaller","snippet":"First we will sort the numbers. Then we will use two pointers to find the number of triplets that sum to a smaller value than the target.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"adding-spaces-to-a-string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/adding-spaces-to-a-string","snippet":"We will iterate over the string and add the spaces to the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Remove\u00a0letter\u00a0to\u00a0equalize\u00a0frequency","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-letter-to-equalize-frequency","snippet":"We will count the frequency of each letter. Then we will find the minimum and maximum frequency. If the minimum frequency is equal to the maximum frequency, then we can remove any letter. Otherwise, we will remove the letter with the maximum frequency...."},{"title":"Leftmost\u00a0column\u00a0with\u00a0at\u00a0least\u00a0a\u00a0one","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/leftmost-column-with-at-least-a-one","snippet":"We do a binary search on each of the $m$ rows, finding the earliest <code>1<\/code> on each. On this binary search, we only search the first minCol columns, where minCol is the earliest column where we have found a 1 so far; at first we set minCol = n...."},{"title":"Count\u00a0number\u00a0of\u00a0ways\u00a0to\u00a0place\u00a0houses","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-number-of-ways-to-place-houses","snippet":"One side of the road has no effect on the other side of the road, so we can put house in both side independently. For one side, we could have number of ways as fibonacci sequence. We we calculate the number of ways for both side, we have to multiply them..."},{"title":"Design\u00a0a\u00a0leaderboard","categories":["array-and-hashmap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-a-leaderboard","snippet":"We will use a hashmap to store the score of each player. We will store the score of each player and we can look up in constant time.\n\n\n\nTime complexity: <code>O(1)<\/code> for <code>addScore<\/code> and <code>reset<\/code> and <code>O(nlog(n))<\/code> for..."},{"title":"Maximum\u00a0tastiness\u00a0of\u00a0candy\u00a0basket","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-tastiness-of-candy-basket","snippet":"We will sort the prices of the candies. Then we run a binary search in the range 0 to the maximum difference between the candies. The check function iterates over the array prices and checks if the given value x can be the minimum difference for any..."},{"title":"Minimum\u00a0increment\u00a0to\u00a0make\u00a0array\u00a0unique","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-increment-to-make-array-unique","snippet":"We will sort the array and iterate over the array. If the current element is smaller than the previous element, we will increment the current element to the previous element plus one.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity:..."},{"title":"Minimum\u00a0path\u00a0cost\u00a0in\u00a0a\u00a0grid","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-path-cost-in-a-grid","snippet":"We will use recursion with memoization to solve this problem. The function <code>helper<\/code> takes the current position <code>(r, c)<\/code> and the current cost <code>cost<\/code>. If the current position is the destination, we return the current cost...."},{"title":"Minimum\u00a0penalty\u00a0for\u00a0a\u00a0shop","categories":["array-and-hashmap","greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-penalty-for-a-shop","snippet":"We will count the number of penaly and then iterate over the customers, canculate the minimum penalty for each customer and add it to the total penalty.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Minimum\u00a0remove\u00a0to\u00a0make\u00a0valid\u00a0parentheses","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-remove-to-make-valid-parentheses","snippet":"We will use a stack to store the index of the open parentheses. If we see a close parentheses, we will pop the stack. If the stack is empty, we will mark the close parentheses as invalid. After we finish the iteration, we will mark all the open..."},{"title":"First\u00a0day\u00a0where\u00a0you\u00a0have\u00a0been\u00a0in\u00a0all\u00a0the\u00a0rooms","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/first-day-where-you-have-been-in-all-the-rooms","snippet":"The idea is that we need to go back a lot of times. Define by dp[i] is number of days to reach cell i. We can only reach it from the cell i-1, so we need at least dp[i-1] steps. Then it will lead us to dp[A[i-1]] cell, because we visited i-1 for the..."},{"title":"Maximum\u00a0bags\u00a0with\u00a0full\u00a0capacity\u00a0of\u00a0rocks","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-bags-with-full-capacity-of-rocks","snippet":"We will sort the rocks by weight and then iterate over them. If the current rock fits in the bag, we will add it to the bag. Otherwise, we will create a new bag.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code>\nSpace complexity: <code>O(n)<\/code>"},{"title":"Next\u00a0palindrome\u00a0using\u00a0same\u00a0digits","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/next-palindrome-using-same-digits","snippet":"We will find the next permutation that is greater than the first half of the palindrome, say greaterHalf. Then add it to the mid item if there is one and to reversed of greaterHalf.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Perfect\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/perfect-number","snippet":"We will find all the divisors of the number and then sum them up. If the sum is equal to the number, then it is a perfect number.\n\n\n\nTime complexity: <code>O(sqrt(n))<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Prefix\u00a0and\u00a0suffix\u00a0search","categories":["array-and-hashmap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/prefix-and-suffix-search","snippet":"We will generate all possible prefixes and suffixes for each word and store them in a hashmap. Then, we will iterate over the queries and return the maximum weight.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Synonymous\u00a0sentences","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/synonymous-sentences","snippet":"We will create a graph where the nodes are the words and the edges are the synonyms. Then we will do a DFS to find all the possible sentences and add that to a hashset to remove duplicates. Finally, we will sort the sentences and return them.\n\n\n\nTime..."},{"title":"XOR\u00a0operation\u00a0in\u00a0an\u00a0array","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/xor-operation-in-an-array","snippet":"We will generate the array and then XOR all the elements.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>\n\nWe can also use <code>reduce<\/code> function to XOR all the elements."},{"title":"Bitwise\u00a0or\u00a0of\u00a0all\u00a0subsequence\u00a0sums","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/bitwise-or-of-all-subsequence-sums","snippet":"We will iterate over the array and update the prefix sum and bitwise or of all subsequence sums.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Out\u00a0of\u00a0boundary\u00a0paths","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/out-of-boundary-paths","snippet":"We will solve the problem recursively. We will use a memo to store the number of paths from <code>(i, j)<\/code> to <code>(m, n)<\/code>.\n\n\n\nTime complexity: <code>O(mn)<\/code> \nSpace complexity: <code>O(mn)<\/code>"},{"title":"Shortest\u00a0unsorted\u00a0continuous\u00a0subarray","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-unsorted-continuous-subarray","snippet":"We will sort the array and find the first and last index where the elements are different.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Count\u00a0anagrams","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-anagrams","snippet":"It is obvious that the answer is the product of the number of unique permutations for each word in a sentence. The last one is just the number of permutations of all letters (treating same letters as distinct, i.e. n!) corrected (divided) by the number..."},{"title":"Longest\u00a0subsequence\u00a0with\u00a0limited\u00a0sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-subsequence-with-limited-sum","snippet":"We will sort the numbers and then create a prefix sum array. Then we will iterate over the numbers and find the index of the largest number that is less than or equal to <code>limit - nums[i]<\/code>. We will update the result.\n\n\n\nTime complexity:..."},{"title":"Minimum\u00a0number\u00a0of\u00a0moves\u00a0to\u00a0make\u00a0palindrome","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-moves-to-make-palindrome","snippet":"We will iterate over the string and count the number of moves for each character. We will update the result.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Most\u00a0popular\u00a0video\u00a0creator","categories":["array-and-hashmap","heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/most-popular-video-creator","snippet":"We will count the number of videos for each creator. Then we will iterate over the videos and count the number of views for each creator. We will update the result.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Reward top k students","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reward-top-k-students","snippet":"We will sort the students by their scores and then iterate over the students and reward them.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Take\u00a0k\u00a0of\u00a0each\u00a0character\u00a0from\u00a0left\u00a0and\u00a0right","categories":["array-and-hashmap","two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/take-k-of-each-character-from-left-and-right","snippet":"We will count the occurance of a, b and c. Then we will iterate over the string and take k characters from the left and right. We will update the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Beautiful\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/beautiful-array","snippet":"We will use recursion to solve the problem. We will call the helper function on odd numbers and even numbers. We will return the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Custom\u00a0sort\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/custom-sort-string","snippet":"We will use a hashmap to store the order of characters in <code>order<\/code>. We will iterate over <code>s<\/code> and store the characters in a list. We will sort the list using the order of characters in <code>order<\/code>. We will return the res...."},{"title":"Domino\u00a0and\u00a0tromino\u00a0tiling","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/domino-and-tromino-tiling","snippet":"We will use dynamic programming to solve the problem. We will use <code>dp[i]<\/code> to store the number of ways to tile <code>i<\/code> units. We will use <code>dp[i] = dp[i-1] + dp[i-2] + 2 * dp[i-3]<\/code> to calculate the number of ways to tile..."},{"title":"Number\u00a0of\u00a0distinct\u00a0islands","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-distinct-islands","snippet":"We will use a set to store the islands. We will iterate over the grid and call the dfs function on the current cell. We will return the result.\n\n\n\nTime complexity: <code>O(mn)<\/code> \nSpace complexity: <code>O(mn)<\/code>"},{"title":"Valid\u00a0triangle\u00a0number","categories":["greedy","binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-triangle-number","snippet":"We will sort the array. We will iterate over the array and use two pointers to find the number of valid triangles. We will return the result.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Convert\u00a0binary\u00a0search\u00a0tree\u00a0to\u00a0sorted\u00a0doubly\u00a0linked\u00a0list","categories":["linked-list","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-binary-search-tree-to-sorted-doubly-linked-list","snippet":"We do an inorder traversal and make an arr of sorted nodes. We then create the doubly linked list by iterating through the array.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Count\u00a0good\u00a0meals","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-good-meals","snippet":"We will use a hashmap to solve this problem. We will iterate over the <code>deliciousness<\/code> array and for each element, we will check if the element is a power of two. If it is, we will add the element to the hashmap. If it is not, we will check if..."},{"title":"Flatten\u00a0a\u00a0multilevel\u00a0doubly\u00a0linked\u00a0list","categories":["linked-list","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flatten-a-multilevel-doubly-linked-list","snippet":"We will use a recursive DFS to solve this problem. We will iterate over the <code>head<\/code> linked list and for each node, we will check if the node has a child. If it does, we will recursively call the function on the child and the next node. We will..."},{"title":"Check\u00a0if\u00a0there\u00a0is\u00a0a\u00a0path\u00a0with\u00a0equal\u00a0number\u00a0of\u00a00s\u00a0and\u00a01s","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-there-is-a-path-with-equal-number-of-0s-and-1s","snippet":"We will use top-down dynamic programming to solve this problem. We will create a <code>dfs<\/code> function to find if there is a path from the current node to the end node. We will return the result of the <code>dfs<\/code> function. We will use..."},{"title":"Largest\u00a0values\u00a0from\u00a0labels","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-values-from-labels","snippet":"We will use a greedy approach to solve this problem. We will sort the values in descending order and then iterate over the values. We will keep track of the number of items with each label. We will add the value to the result if the number of items with..."},{"title":"Sum\u00a0of\u00a0distances\u00a0in\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-distances-in-tree","snippet":"We will create a tree from the edges. We will create a <code>sums<\/code> array to store the sum of distances from each node to all other nodes. We will create a <code>counts<\/code> array to store the number of nodes in the subtree rooted at each node. We..."},{"title":"Find\u00a0distance\u00a0in\u00a0a\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-distance-in-a-binary-tree","snippet":"We will use a recursive function to find the distance between two nodes. The function will return the distance between the two nodes if both nodes are in the tree. Otherwise, it will return <code>-1<\/code>. If the current node is one of the two nodes, we..."},{"title":"Largest\u00a0merge\u00a0of\u00a0two\u00a0strings","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-merge-of-two-strings","snippet":"We will iterate through the two strings and compare the current character of each string. If the current character of <code>word1<\/code> is greater than the current character of <code>word2<\/code>, we will add the current character of <code>word1<\/code>..."},{"title":"Maximal\u00a0network\u00a0rank","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximal-network-rank","snippet":"We will create an adjacency list to represent the graph. We will iterate through all pairs of cities and find the number of common neighbors. If the number of common neighbors is greater than the current maximum, we will update the maximum. We will..."},{"title":"Possible\u00a0bipartition","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/possible-bipartition","snippet":"We will create an adjacency list from the dislikes list. Then we start traversing the graph with BFS, and for each alternate level, we will assign one color. If two adjacent node has the same color, then we immediately return false. If we can traverse..."},{"title":"Backspace\u00a0string\u00a0compare","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/backspace-string-compare","snippet":"We will create a helper function that will take a string and return the string after applying the backspace operation. To evaluate, we will append each character to a stack, and whenever we hit a backspace we pop it from the stack. Then we will compare..."},{"title":"Longest\u00a0mountain\u00a0in\u00a0array","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-mountain-in-array","snippet":"We will use two pointers to keep track of the start and end of the mountain. We will iterate through the array and keep track of the start and end of the mountain. If the current element is greater than the previous element, we will increment the end..."},{"title":"Minimum\u00a0initial\u00a0energy\u00a0to\u00a0finish\u00a0tasks","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-initial-energy-to-finish-tasks","snippet":"We will sort the tasks by the difference between the cost and the energy. We will iterate through the tasks and keep track of the current energy. If the current energy is less than the cost of the task, we will add the difference to the initial energy...."},{"title":"Shifting\u00a0letters","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shifting-letters","snippet":"We will calculate the total shift and then shift each character by the total shift. We will keep track of the total shift by subtracting the shift from the total shift. We will use a helper function to shift the character by the shift.\n\n\n\nTime..."},{"title":"Ways\u00a0to\u00a0make\u00a0a\u00a0fair\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/ways-to-make-a-fair-array","snippet":"We will use odd prefix and even prefix to keep track of the sum of the odd and even indices. We will iterate through the array and keep track of the odd and even prefix. We will use a helper function to calculate the sum of the odd and even indices. We..."},{"title":"Binary\u00a0tree\u00a0longest\u00a0consecutive\u00a0sequence","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-longest-consecutive-sequence","snippet":"We will use a recursive function to find the longest consecutive sequence in the left subtree and the right subtree. Then we will compare the longest consecutive sequence in the left subtree and the right subtree with the current node. If the current..."},{"title":"Check\u00a0if\u00a0array\u00a0pairs\u00a0are\u00a0divisible\u00a0by\u00a0k","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-array-pairs-are-divisible-by-k","snippet":"We will use a hashmap to store the frequency of each remainder. Then we will iterate over the hashmap and check if the remainder is divisible by <code>k<\/code>. If it is, then we will check if the frequency of the remainder is even. If it is not, then we..."},{"title":"Clone\u00a0binary\u00a0tree\u00a0with\u00a0random\u00a0pointer","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/clone-binary-tree-with-random-pointer","snippet":"We will use a hashmap to store the mapping between the original node and the cloned node. Then we will iterate over the hashmap and clone the random pointer.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Decode\u00a0the\u00a0message","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/decode-the-message","snippet":"We will use a hashmap to map the characters to their corresponding letters. Then iterate over the message, replace the characters with their corresponding letters and return the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Delete\u00a0n\u00a0nodes\u00a0after\u00a0m\u00a0nodes\u00a0of\u00a0a\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-n-nodes-after-m-nodes-of-a-linked-list","snippet":"We will create a dummy node and attach the head node to it. Then we will do the following:\n\n\nUse an indicator i to count the number of already-passed list nodes\nKeep moving head node forward as long as i &lt; m-1\nRemove the next n nodes and reset i to 0..."},{"title":"Maximum\u00a0number\u00a0of\u00a0books\u00a0you\u00a0can\u00a0take","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-books-you-can-take","snippet":"Use stack to find how long a consecutive ramp can be built at each index. Previous higher shelves are popped out of the stack since they do not impact how long we can build. If ramp terminated by a previous lower shelf, ramp at the lower shelf can be..."},{"title":"Path\u00a0crossing","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-crossing","snippet":"We will start with the origin <code>(0, 0)<\/code> and for each move we will update the current position. If the current position is already in the set of visited positions, then we have a path crossing.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Check\u00a0if\u00a0there\u00a0is\u00a0a\u00a0valid\u00a0parentheses\u00a0string\u00a0path","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-there-is-a-valid-parentheses-string-path","snippet":"We will use top-down memoization to solve the problem. For every opening parenthesis we add 1 to our current and for every closing parenthesis we subtract 1 from our current. If we ever reach a negative number, we return false. If we reach the end of the..."},{"title":"Day\u00a0of\u00a0the\u00a0year","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/day-of-the-year","snippet":"We can use the <code>datetime<\/code> module to convert the date to a datetime object and then use the <code>timetuple<\/code> method to get the day of the year.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(1)<\/code>\n\nWe can also use..."},{"title":"Pancake\u00a0sorting","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pancake-sorting","snippet":"We will iterate through the array, and for each element, we will find the index of the element in the array. Then we will reverse the array from the index of the element to the end of the array. Then we will reverse the array from the beginning of the..."},{"title":"Powerful\u00a0integers","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/powerful-integers","snippet":"We can use brute force to calculate all the possible values of <code>x^i + y^j<\/code> until the value is less than the bound and store them in a set. Then we can return the set as a list.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity:..."},{"title":"Add\u00a0two\u00a0integers","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-two-integers","snippet":"This is a stupid problem. We can just add to numbers and return the result.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Apply\u00a0discount\u00a0to\u00a0prices","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/apply-discount-to-prices","snippet":"We will split the sentence into words. Then we will iterate through the words, and for each word, if we found a word with the <code>$<\/code> prefix, we will replace the amount with the discounted amount. Otherwise, we will just append the word to the..."},{"title":"Maximum\u00a0sum\u00a0score\u00a0of\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-sum-score-of-array","snippet":"We will calculate the prefix sum of the array. Then we will iterate through the array, and for each element, we will find the maximum sum of the subarray that ends at the current element. Then we will update the maximum sum of the subarray that ends at..."},{"title":"Minimum\u00a0rounds\u00a0to\u00a0complete\u00a0all\u00a0tasks","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-rounds-to-complete-all-tasks","snippet":"We will count the different tasks and calculate the number of rounds for each task. Then we will return the maximum number of rounds.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Number\u00a0of\u00a0boomerangs","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-boomerangs","snippet":"We will use a hashmap to store the distance between each point and the current point. Then we will iterate through the hashmap to calculate the number of boomerangs.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Replace\u00a0elements\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/replace-elements-in-an-array","snippet":"We will use a hashmap to store the index of the input array for constant time lookup. Then we will iterate through the operations, and for each operation, we will update the value of the input array. We will also update the index of the input array in..."},{"title":"Root\u00a0equals\u00a0sum\u00a0of\u00a0children","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/root-equals-sum-of-children","snippet":"We will check the value of root with the sum of the rest of the tree. If the value of root is equal to the sum of the rest of the tree, then we will return <code>True<\/code>. Otherwise, we will return <code>False<\/code>.\n\n\n\nTime complexity:..."},{"title":"Ternary\u00a0expression\u00a0parser","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/ternary-expression-parser","snippet":"We will use a stack to evaluate the expression. We start from the end of the expression, then append the value to the stack. If the number of element in the stack is more than 2, and the second last element is a <code>?<\/code>, then we pop 5 element of..."},{"title":"Encode\u00a0number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/encode-number","snippet":"The following sequence can be built up form the ealier result. So we can search index of the prefix part, for example:\n\nf(5) = \"10\", f(6) = \"11\"\n\nThe prefix are both f(2) = \"1\"\n\nso we found that f(n) has f((n - 1) \/ 2) as prefix.\n\n\n\nTime complexity:..."},{"title":"Number\u00a0of\u00a0closed\u00a0islands","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-closed-islands","snippet":"We will use a DFS approach to solve this problem. We will iterate through the grid. We will check if the current cell is a land. We will check if the current cell is a closed island. We will return the number of closed islands.\n\n\n\nTime complexity:..."},{"title":"Widest\u00a0pair\u00a0of\u00a0indices\u00a0with\u00a0equal\u00a0range\u00a0sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/widest-pair-of-indices-with-equal-range-sum","snippet":"We will use a prefix sum approach to solve this problem. We will create a prefix sum array. We will create a hashmap. We will iterate through the prefix sum array. We will calculate the difference between the current prefix sum and the target. We will..."},{"title":"Campus\u00a0bikes II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/campus-bikes-ii","snippet":"We will use a dynamic programming approach to solve this problem. We will create a memoization table. We will iterate through the memoization table. We will iterate through the bikes. We will check if the bike is not assigned. We will assign the bike to..."},{"title":"Append\u00a0k\u00a0integers\u00a0with\u00a0minimal\u00a0sum","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/append-k-integers-with-minimal-sum","snippet":"We will use a greedy approach to solve this problem. We calculate the sum of the first <code>k<\/code> integers. We will iterate over the array and if the current number is less than <code>k<\/code>, we will add the difference between <code>k<\/code> and..."},{"title":"Count\u00a0number\u00a0of\u00a0homogenous\u00a0substrings","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-number-of-homogenous-substrings","snippet":"We will use a sliding window approach to solve this problem. We will iterate over the string and keep track of the start and end of the current substring. We will increment the end of the substring until we find a different character. We will calculate..."},{"title":"Minimum\u00a0number\u00a0of\u00a0operations\u00a0to\u00a0move\u00a0all\u00a0balls\u00a0to\u00a0each\u00a0box","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-operations-to-move-all-balls-to-each-box","snippet":"The question needs to search for balls left and right relative to the current box. If we use [1,1,0] as example, in the second box (i.e. boxes[1]):\nYou will need to find the first box value (go left), and the third box value (go right), which makes it..."},{"title":"Ugly number III","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/ugly-number-iii","snippet":"We will use a binary search approach to solve this problem. We will find the smallest number that is divisible by <code>a<\/code>, <code>b<\/code>, and <code>c<\/code>. We will find the smallest number that is divisible by <code>a<\/code> and <code>b<\/code>...."},{"title":"Check\u00a0whether\u00a0two\u00a0strings\u00a0are\u00a0almost\u00a0equivalent","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-whether-two-strings-are-almost-equivalent","snippet":"We will merge all the characters of the string to a hash set and we will keep on iterating over the characters of the set. Then we count the difference between the characters of the string and the characters of the set. If the difference is greater than..."},{"title":"Detect\u00a0capital","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/detect-capital","snippet":"We can use python's built in fuction to check the conditions.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Increasing\u00a0subsequences","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/increasing-subsequences","snippet":"We will use backtracking to get all the subsequence of the array. We will keep on iterating over the array and we will check whether the current element is greater than the last element of the current subsequence. If it is, we will add the current..."},{"title":"Letter\u00a0case\u00a0permutation","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/letter-case-permutation","snippet":"We will use backtracking to solve this problem. We will iterate over the string and if we encounter a letter, we will add the lowercase and uppercase version of the letter to the result. If we encounter a digit, we will just add the digit to the result...."},{"title":"Moving\u00a0average\u00a0from\u00a0data\u00a0stream","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/moving-average-from-data-stream","snippet":"We will use a queue to store the values. We will keep track of the sum of the values in the queue. We will add the new value to the queue and remove the oldest value from the queue. We will return the sum of the values in the queue divided by the size of..."},{"title":"Average\u00a0waiting\u00a0time","categories":["intervals","array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/average-waiting-time","snippet":"We will keep on iterating over the intervals and we will check whether the current interval can be served. If it can be served, we will update the current time to be the maximum of the current time and the arrival time of the current interval. We will..."},{"title":"Longest\u00a0square\u00a0streak\u00a0in\u00a0an\u00a0array","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-square-streak-in-an-array","snippet":"We will use a greedy approach to solve this problem. We will keep on iterating over the sorted array and we will check whether the square of the number is available in the array. If it is available, we will increment the streak by 1 and we will update..."},{"title":"Longest\u00a0univalue\u00a0path","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-univalue-path","snippet":"This problem is very similar to diameter of the tree problem. We will keep on iterating over the nodes of the tree and we will check whether the current node is the root of the longest univalue path. If it is, we will update the longest univalue path to..."},{"title":"Lowest\u00a0common\u00a0ancestor\u00a0of\u00a0deepest\u00a0leaves","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lowest-common-ancestor-of-deepest-leaves","snippet":"We will traverse the tree with DFS and it will return the deepest depth of the tree and the lowest common ancestor of the deepest leaves. We will keep on iterating over the nodes of the tree and we will check whether the current node is the root of the..."},{"title":"Maximum\u00a0level\u00a0sum\u00a0of\u00a0a\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-level-sum-of-a-binary-tree","snippet":"We will traverse the tree with BFS and we will keep on iterating over the nodes of the tree. We will keep on adding the nodes of the current level to a queue and we will keep on adding the values of the nodes of the current level to a variable. We will..."},{"title":"Maximum\u00a0nesting\u00a0depth\u00a0of\u00a0two\u00a0valid\u00a0parentheses\u00a0strings","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-nesting-depth-of-two-valid-parentheses-strings","snippet":"We will keep on iterating over the string and we will keep on pushing the current character into the stack. If the current character is <code>(<\/code>, we will increment the current depth. If the current character is <code>)<\/code>, we will decrement the..."},{"title":"Smallest\u00a0subtree\u00a0with\u00a0all\u00a0the\u00a0deepest\u00a0nodes","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/smallest-subtree-with-all-the-deepest-nodes","snippet":"We will traverse the tree with DFS and it will return the deepest depth of the tree and the lowest common ancestor of the deepest leaves. We will keep on iterating over the nodes of the tree and we will check whether the current node is the root of the..."},{"title":"Best\u00a0time\u00a0to\u00a0buy\u00a0and sell\u00a0stock\u00a0with\u00a0transaction\u00a0fee","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock-with-transaction-fee","snippet":"We will use top-down dynamic programming method to solve the problem. We will create a memoization table to store the maximum profit for each day. We will use a recursive function to calculate the maximum profit for each day. If the current day is the..."},{"title":"Minimum\u00a0cost\u00a0to\u00a0connect\u00a0sticks","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-cost-to-connect-sticks","snippet":"We will use a heap to store the sticks. We will keep on popping the two smallest sticks from the heap and we will add their sum to the result. We will push the sum of the two sticks to the heap. We will keep on doing this until there is only one stick..."},{"title":"Remove\u00a0nodes\u00a0from\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-nodes-from-linked-list","snippet":"We will use recursion to remove the nodes from the linked list. If the current node is not a leaf node, we will check if the next node is a leaf node. If it is, we will remove the next node. If it is not, we will call the function recursively on the next..."},{"title":"Removing\u00a0stars\u00a0from\u00a0a\u00a0string","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/removing-stars-from-a-string","snippet":"We will use a stack to store the characters of the string. If the current character is a star, we will pop the last character from the stack. If the current character is not a star, we will push it to the stack. At the end, we will return the stack as a..."},{"title":"Find\u00a0the\u00a0longest\u00a0substring\u00a0containing\u00a0vowels\u00a0in\u00a0even\u00a0counts","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-longest-substring-containing-vowels-in-even-counts","snippet":"We will use a sliding window to solve this problem. We will keep track of the number of occurrences of each vowel in the window. We will then check if the number of occurrences of each vowel is even. If it is, we will update the answer.\n\n\n\nTime..."},{"title":"Maximum\u00a0product\u00a0of\u00a0splitted\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-product-of-splitted-binary-tree","snippet":"We will calculate the sum of all nodes in the tree and then we will calculate the sum of all nodes in the left and right subtrees. The answer will be the maximum of the product of the sum of the left and right subtrees and the product of the sum of the..."},{"title":"Partition\u00a0array\u00a0such\u00a0that\u00a0maximum\u00a0difference\u00a0is\u00a0k","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-array-such-that-maximum-difference-is-k","snippet":"We will sort the array and then we will iterate through the array and we will check if the difference between the current element and the previous element is greater than k, if it is, then we increate the result count by 1.\n\n\n\nTime complexity:..."},{"title":"Valid\u00a0palindrome IV","categories":["array-and-hashmap","two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-palindrome-iv","snippet":"We will use two pointers to check if the string is a palindrome. We will start from the beginning and the end of the string and we will check if the characters are the same. If they are not, we will count the mismatch. If the mismatch is greater than 2,..."},{"title":"Add\u00a0two\u00a0polynomials\u00a0represented\u00a0as\u00a0linked\u00a0lists","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-two-polynomials-represented-as-linked-lists","snippet":"We will use the same approach as in the merge two sorted lists problem. We will iterate over both lists and add the coefficients of the nodes with the same power. If the coefficient is zero, we will skip the node.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Design\u00a0hit\u00a0counter","categories":["design","queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-hit-counter","snippet":"We will use a queue to store the timestamps of the hits. We will remove the timestamps that are older than 300 seconds. Then we will return the size of the queue.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Longest\u00a0substring\u00a0with\u00a0at\u00a0least\u00a0k\u00a0repeating\u00a0characters","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-substring-with-at-least-k-repeating-characters","snippet":"The idea is that any characters in the string that do not satisfy the requirement break the string in multiple parts that do not contain these characters, and for each part we should check the requirement again. There are similar solutions (not many),..."},{"title":"Maximize\u00a0the\u00a0confusion\u00a0of\u00a0an\u00a0exam","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximize-the-confusion-of-an-exam","snippet":"We will use a sliding window to solve this problem. The window will be the size of the maximum number of consecutive characters that can be changed. We will count the maximum number of consecutive characters that are the same as the <code>T<\/code>..."},{"title":"Number\u00a0of\u00a0pairs\u00a0of\u00a0interchangeable\u00a0rectangles","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-pairs-of-interchangeable-rectangles","snippet":"We will use a hash map to store the number of rectangles with each width and height. Then we will iterate over the hash map and count the number of pairs of rectangles that can be interchanged.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Find root of N-ary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-root-of-n-ary-tree","snippet":"We will sum up all the node values of the tree, then all the substruct all the children node values. The remaining value is the root node value.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Insert\u00a0into\u00a0a\u00a0sorted\u00a0circular\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/insert-into-a-sorted-circular-linked-list","snippet":"We will use a <code>prev<\/code> pointer to store the previous node. If the current node is greater than the previous node and less than the next node, then we will insert the node between the previous node and the current node. If the current node is..."},{"title":"Maximum\u00a0number\u00a0of\u00a0non\u00a0overlapping\u00a0subarrays\u00a0with\u00a0sum\u00a0equals\u00a0target","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","snippet":"We can be greedy and use a hash set to store the prefix sum. If the prefix sum minus <code>target<\/code> is in the hash set, then we will update the result and clear the hash set. We will return the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Range\u00a0frequency\u00a0queries","categories":["binary-search","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/range-frequency-queries","snippet":"We can use a hash map to store the frequency of each number. Then we can use a binary search to find the number of numbers that have a frequency greater than or equal to value.\n\n\n\nTime complexity: <code>O(log(n))<\/code> \nSpace complexity:..."},{"title":"Can\u00a0you\u00a0eat\u00a0your\u00a0favorite\u00a0candy\u00a0on\u00a0your\u00a0favorite\u00a0day","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/can-you-eat-your-favorite-candy-on-your-favorite-day","snippet":"Define a prefix sum of candiesCount. If you label all candies starting from 1 and order them by type:\n\n\n[prefix[candyType]+1, prefix[candyType+1]] are all the candies of type candyType.\nAt minimum, you must eat targetDay+1 candies.\nAt maximum, you can..."},{"title":"Design\u00a0tic\u00a0tac\u00a0toe","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-tic-tac-toe","snippet":"We will use a hash map to store the number of times a row, column, or diagonal has been filled by a player. We will also use a variable to store the number of moves made. If the number of moves is equal to the total number of cells, then the game is a..."},{"title":"Maximum\u00a0size\u00a0subarray\u00a0sum\u00a0equals\u00a0k","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-size-subarray-sum-equals-k","snippet":"We will use prefix sum to solve this problem. We will store the prefix sum in a hash map. If the prefix sum is equal to <code>k<\/code>, then we will update the maximum length. If the prefix sum minus <code>k<\/code> is in the hash map, then we will update..."},{"title":"Minimum\u00a0cost\u00a0to\u00a0buy\u00a0apples","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-cost-to-buy-apples","snippet":"We will use Dijkstra's algorithm to find the shortest path from the source to the target. The cost of each edge is the number of apples in that node.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Number\u00a0of\u00a0subarrays\u00a0having\u00a0even\u00a0product","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-subarrays-having-even-product","snippet":"For a subarray to have an even product, some elements must be even. However, we don't know which one (or which ones). It is simpler to work with conditions of a form \"all elements must satisfy some condition\" instead. For example, for a subarray to have..."},{"title":"Range\u00a0sum\u00a0of\u00a0bst","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/range-sum-of-bst","snippet":"We will traverse the tree with DFS and add the value to the sum if it is in the range.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Words\u00a0within\u00a0two\u00a0edits\u00a0of\u00a0dictionary","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/words-within-two-edits-of-dictionary","snippet":"We will take the brute force approach to solve this problem. For every query, we will go through the dictionary and check if the word is within two edits of the query.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Alert\u00a0using\u00a0same\u00a0key\u00a0card\u00a0three\u00a0or\u00a0more\u00a0times\u00a0in\u00a0a\u00a0one\u00a0hour\u00a0period","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period","snippet":"We will loop over the <code>keyName<\/code> and <code>time<\/code> and add the time to a list. Then we will sort the list and loop over it. We will keep track of the current key name and the current start point. When we reach a new key name, we will add..."},{"title":"Describe\u00a0the\u00a0painting","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/describe-the-painting","snippet":"We will loop over the segments and add the start and end points to a list. Then we will sort the list and loop over it. We will keep track of the current color and the current start point. When we reach a new color, we will add the current color and the..."},{"title":"Encode\u00a0and\u00a0decode\u00a0strings","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/encode-and-decode-strings","snippet":"We will use a delimiter to separate the strings. Then we will loop over the strings and add the length of the string and the delimiter to the result. Finally, we will add the string to the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"largest-bst-subtree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-bst-subtree","snippet":"We will use a recursive function to check if the tree is a BST or not. If it is, we will return the size of the tree. If it's not, we will return the maximum size of the left and right subtrees.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity:..."},{"title":"Number\u00a0of\u00a0ways\u00a0to\u00a0buy\u00a0pens\u00a0and\u00a0pencils","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-ways-to-buy-pens-and-pencils","snippet":"We will loop over the <code>pens<\/code> and <code>pencils<\/code> and add the start and end points to a list. Then we will sort the list and loop over it. We will keep track of the current color and the current start point. When we reach a new color, we..."},{"title":"Find\u00a0center\u00a0of\u00a0star\u00a0graph","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-center-of-star-graph","snippet":"As it's a start graph, each edge will be connected to the center. So we can just check the first 2 edges and return the node that is connected to both of them.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Find\u00a0k\u00a0pairs\u00a0with\u00a0smallest\u00a0sums","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-k-pairs-with-smallest-sums","snippet":"We will use a min heap to store the smallest sum. We will add the first element of each array to the heap. Then we will pop the smallest element from the heap and add the next element of the array from which the smallest element was popped. We will..."},{"title":"Fraction\u00a0to\u00a0recurring\u00a0decimal","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/fraction-to-recurring-decimal","snippet":"We will use a dictionary to store the remainder and the index of the remainder. If the remainder is already in the dictionary, we will add the parenthesis and return the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Middle\u00a0of\u00a0the\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/middle-of-the-linked-list","snippet":"We will take two pointers, one will move one step at a time and the other will move two steps at a time. When the second pointer reaches the end of the list, the first pointer will be at the middle of the list.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Minimum\u00a0score\u00a0of\u00a0a\u00a0path\u00a0between\u00a0two\u00a0cities","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-score-of-a-path-between-two-cities","snippet":"We will create an adjacency list for the graph. Then we traverse the graph with BFS and keep track of the minimum score for each node. We will return the minimum score for the destination node.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"One\u00a0edit\u00a0distance","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/one-edit-distance","snippet":"We will check if the length of the strings are equal or not. If they are equal, we will check if there is only one character that is different. If they are not equal, we will check if the length difference is 1 and if there is only one character that is..."},{"title":"Remove\u00a0interval","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-interval","snippet":"We will iterate over each interval, if the interval doesn't overlap with the to be removed interval, we just add it to the output. If start is less than remove start, we take the remove start as end. If the end is greater than the remove end, we take the..."},{"title":"Wiggle\u00a0sort","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/wiggle-sort","snippet":"We will loop over the array, that 2 elements per iteration, then sort 2 elements once ascending and then descending order and swap them. We will do this until we reach the end of the array.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Implement\u00a0trie II\u00a0(prefix\u00a0tree)","categories":["trie","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/implement-trie-ii-prefix-tree","snippet":"We will use a trie to solve this problem. We will store the count of each word in the trie. We will also store the count of each prefix in the trie. We will increment the count of the word and the prefix whenever we insert a word. We will decrement the..."},{"title":"Minimum\u00a0average\u00a0difference","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-average-difference","snippet":"We will use prefix sum to solve this problem. We will calculate the prefix sum of the first half of the array and the second half of the array. Then we will iterate over the first half of the array and find the index of the element in the second half of..."},{"title":"Minimum\u00a0number\u00a0of\u00a0steps\u00a0to\u00a0make\u00a0two\u00a0strings\u00a0anagram II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-steps-to-make-two-strings-anagram-ii","snippet":"We will count the character frequency of both the strings. We will iterate over the character frequency of the first string and for each character we will find the number of characters that we need to remove from the second string to make the character..."},{"title":"Minimum\u00a0number\u00a0of\u00a0steps\u00a0to\u00a0make\u00a0two\u00a0strings\u00a0anagram","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-steps-to-make-two-strings-anagram","snippet":"We will count the character frequency of both the strings. We will iterate over the character frequency of the first string and for each character we will find the number of characters that we need to remove from the second string to make the character..."},{"title":"Find\u00a0k\u00a0length\u00a0substrings\u00a0with\u00a0no\u00a0repeated\u00a0characters","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-k-length-substrings-with-no-repeated-characters","snippet":"We will use a sliding window to solve this problem. The window will be a substring of the input string. The window will be valid if it has no repeated characters. We will keep track of the number of valid windows.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Longest\u00a0string\u00a0chain","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-string-chain","snippet":"We will use DFS to find the lognest possible word chain end at word. To calculate dfs(word), we try all predecessors of word word and get the maximum length among them.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Longest\u00a0substring\u00a0with\u00a0at\u00a0most\u00a0k\u00a0distinct\u00a0characters","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-substring-with-at-most-k-distinct-characters","snippet":"We will use a sliding window to solve this problem. The window will be a substring of the input string. The window will be valid if it has at most k distinct characters. We will keep track of the maximum length of the valid window.\n\n\n\nTime complexity:..."},{"title":"Longest\u00a0substring\u00a0with\u00a0at\u00a0most\u00a0two\u00a0distinct\u00a0characters","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-substring-with-at-most-two-distinct-characters","snippet":"We will use a sliding window to solve this problem. The window will be a substring of the input string. The window will be valid if it has at most two distinct characters. We will keep track of the maximum length of the valid window.\n\n\n\nTime complexity:..."},{"title":"Number of connected components in an undirected graph","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-connected-components-in-an-undirected-graph","snippet":"First we will create an adjacency list from the edges. Then we will run DFS from the very first node, and added it to out visited set, also count it as a connected component. In the process of DFS traversal, it will add all the connected components to..."},{"title":"Number\u00a0of\u00a0subarrays\u00a0with\u00a0gcd\u00a0equal\u00a0to\u00a0k","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-subarrays-with-gcd-equal-to-k","snippet":"We will take every possible subarray of the input array and calculate the gcd of the subarray. If the gcd is equal to k, we will increment the count of such subarrays.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Number\u00a0of\u00a0subarrays\u00a0with\u00a0lcm\u00a0equal\u00a0to\u00a0k","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-subarrays-with-lcm-equal-to-k","snippet":"We will take every possible subarray of the input array and calculate the lcm of the subarray. If the lcm is equal to k, we will increment the count of such subarrays.\n\n\n\nTime complexity: <code>O(n^2)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Connecting\u00a0cities\u00a0with\u00a0minimum\u00a0cost","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/connecting-cities-with-minimum-cost","snippet":"We will use Kruskal's algorithm to solve this problem. We will sort the edges in ascending order of their weights. Then we will use Union Find data structure to construct the graph. We will then iterate through the edges and add them to the graph if they..."},{"title":"Determine\u00a0if\u00a0two\u00a0strings\u00a0are\u00a0close","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/determine-if-two-strings-are-close","snippet":"We will check if the two strings are equal. If they are not equal, then we will return false. If they are equal, then we will check if the frequency of each character in the two strings are equal. If they are not equal, then we will return false. If they..."},{"title":"Minimum\u00a0cost\u00a0to\u00a0reach\u00a0city\u00a0with\u00a0discounts","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-cost-to-reach-city-with-discounts","snippet":"We will use Dijkstra's algorithm to solve this problem. We will create a graph with the cities as the nodes and the edges as the roads. We will then use Dijkstra's algorithm to find the shortest path from the source city to the destination city. We will..."},{"title":"Nth\u00a0digit","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/nth-digit","snippet":"Integers can be divided into groups 1-9, 10-99, 100-999, 1000-9999, etc. Every number in the i-th group has i digits. First we want to find the group which contains the number where does the digit come from. (For example 2, the output comes from 10,..."},{"title":"Previous\u00a0permutation\u00a0with\u00a0one\u00a0swap","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/previous-permutation-with-one-swap","snippet":"We will iterate through the array from the end. We will keep track of the index of the first element that is smaller than the previous element. We will then iterate through the array from the end. We will keep track of the index of the first element that..."},{"title":"Search\u00a0in\u00a0a\u00a0sorted\u00a0array\u00a0of\u00a0unknown\u00a0size","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-in-a-sorted-array-of-unknown-size","snippet":"We will use binary search to find the index of the target. We will start with the index 1. If the element at the index is smaller than the target, then we will double the index. If the element at the index is larger than the target, then we will use..."},{"title":"Determine\u00a0if\u00a0string\u00a0halves\u00a0are\u00a0alike","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/determine-if-string-halves-are-alike","snippet":"We will itrerate over the string, for first half we increase the count and for second half we decrease the count. At the end if the count is 0, then the string halves are alike.\n\n\n\nTime complexity: <code>O(n)<\/code>\nSpace complexity: <code>O(1)<\/code>"},{"title":"Evaluate\u00a0the\u00a0bracket\u00a0pairs\u00a0of\u00a0a\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/evaluate-the-bracket-pairs-of-a-string","snippet":"We will use a hashmap to store the key-value pairs. Then we will iterate over the string and if we encounter a <code>(<\/code>, we will start a new string. If we encounter a <code>)<\/code>, we will check if the string is in the hashmap, if yes, we will..."},{"title":"Factorial\u00a0trailing\u00a0zeroes","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/factorial-trailing-zeroes","snippet":"We will count the number of trailing zeroes in the factorial of the given number. We will count the number of 5s in the factorial of the given number. We will keep dividing the number by 5 and add the quotient to the count. At the end we will return the..."},{"title":"Majority\u00a0element II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/majority-element-ii","snippet":"We will count the frequency of each element in the array and return the elements whose frequency is greater than <code>n\/\/3<\/code>. We will use a hashmap to store the frequency of each element, and a set to store the elements whose frequency is greater..."},{"title":"Path sum IV","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-sum-iv","snippet":"We will convert the given array into a tree using Node objects. Afterwards, for each path from root to leaf, we can add the sum of that path to our answer.\n\nThere are two steps, the tree construction, and the traversal.\n\nIn the tree construction, we have..."},{"title":"Single\u00a0row\u00a0keyboard","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/single-row-keyboard","snippet":"We will iterate over the word, find the index of the character in the keyboard and add the difference between the current and previous index to the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Bitwise\u00a0xor\u00a0of\u00a0all\u00a0pairings","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/bitwise-xor-of-all-pairings","snippet":"From Boolean algebra we know that n^0 = n and n^n = 0, from which we can infer that the xor of an even count of an integer n is 0, and the xor of an odd count of an integer n is n. We also know that the ^ operator is commutative and associative.\n\nXOR of..."},{"title":"Count\u00a0nodes\u00a0equal\u00a0to\u00a0average\u00a0of\u00a0subtree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-nodes-equal-to-average-of-subtree","snippet":"We will traverse the tree in post-order fashion. For each node, we will calculate the sum of all nodes in its subtree and the number of nodes in its subtree. Then we will check if the average of the subtree is equal to the value of the current node. If..."},{"title":"Find\u00a0all\u00a0lonely\u00a0numbers\u00a0in\u00a0the\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-all-lonely-numbers-in-the-array","snippet":"We will count the occurrences of each number in the array and return the numbers that have only one occurrence and no adjacent number is present in the list.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of the array \nSpace complexity:..."},{"title":"Find\u00a0leaves\u00a0of\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-leaves-of-binary-tree","snippet":"We will traverse the tree in post-order fashion. For each node, we will check if it is a leaf node. If it is, we will append the value of the node in a list. Then we will check if the left and right child of the node are leaf nodes. If they are, we will..."},{"title":"Fizz buzz","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/fizz-buzz","snippet":"We will iterate over the numbers from 1 to n and append the corresponding string to the result list. If the number is divisible by 3, we will append \"Fizz\" to the result list. If the number is divisible by 5, we will append \"Buzz\" to the result list. If..."},{"title":"Maximum\u00a0average\u00a0subtree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-average-subtree","snippet":"We will traverse the tree in post-order fashion. For each node, we will calculate the sum of all nodes in its subtree and the number of nodes in its subtree. Then we will check if the average of the subtree is equal to the value of the current node. If..."},{"title":"Maximum\u00a0split\u00a0of\u00a0positive\u00a0even\u00a0integers","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-split-of-positive-even-integers","snippet":"We can be greedy and try to split the number into as many parts as possible. We will start from the 2 and try to split it until we reach the end of the number. If we can't split the number, we will try to split the number starting from the 4 and so on...."},{"title":"Nim\u00a0game","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/nim-game","snippet":"Let us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile,..."},{"title":"Partitioning\u00a0into\u00a0minimum\u00a0number\u00a0of\u00a0deci\u00a0binary\u00a0numbers","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partitioning-into-minimum-number-of-deci-binary-numbers","snippet":"Assume max digit in n is x, because deci-binary only contains 0 and 1, we need at least x numbers to sum up a digit x. So we can just find the max digit in n and return it.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Recover\u00a0a\u00a0tree\u00a0from\u00a0preorder\u00a0traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/recover-a-tree-from-preorder-traversal","snippet":"We save the construction path in a stack. In each loop, we get the number level of '-'. We get the value val of node to add.\n\nIf the size of stack is bigger than the level of node, we pop the stack until it's not.\n\nFinally we return the first element in..."},{"title":"Remove\u00a0duplicates\u00a0from\u00a0an\u00a0unsorted\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicates-from-an-unsorted-linked-list","snippet":"We will use a hashmap to count the frequency of each node in the linked list. Then we will traverse the linked list again and remove the nodes that have frequency greater than 1.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Sparse\u00a0matrix\u00a0multiplication","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sparse-matrix-multiplication","snippet":"We will iterate over the non-zero elements of the first matrix and multiply them with the corresponding elements of the second matrix. We will store the result in a dictionary and return the result.\n\n\n\nTime complexity: <code>O(n^3)<\/code>, n is the..."},{"title":"Unique\u00a0number\u00a0of\u00a0occurrences","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-number-of-occurrences","snippet":"We will count the number of occurrences of each number in the array. We will then check if the number of occurrences is unique using a hash set.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of the array \nSpace complexity: <code>O(n)<\/code>"},{"title":"Unique\u00a0word\u00a0abbreviation","categories":["array-and-hashmap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-word-abbreviation","snippet":"We will use a dictionary to store the count of each abbreviation, and a set to store the words that have been added to the dictionary. If the word is already present in the set, we will return false. If the abbreviation is already present in the..."},{"title":"Verify\u00a0preorder\u00a0sequence\u00a0in\u00a0binary\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/verify-preorder-sequence-in-binary-search-tree","snippet":"Using stack for storing the current node as a check point for the next element. Once the current is larger than the last element in the stack, we know we should take it as the right node. The last element poping out from the stack will be also a checking..."},{"title":"Count\u00a0of\u00a0smaller\u00a0numbers\u00a0after\u00a0self","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-of-smaller-numbers-after-self","snippet":"We will make a sorted copy of the nums. Then we iterate over each number, find the index of the number in the sorted copy, and add the number of numbers smaller than the number to the result.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code>, n is the length..."},{"title":"Count\u00a0univalue\u00a0subtrees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-univalue-subtrees","snippet":"We will use postorder traversal to count the number of univalue subtrees. We will also use a helper function to check if the current node is a univalue subtree.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the number of nodes in the tree \nSpace..."},{"title":"Generate\u00a0a\u00a0string\u00a0with\u00a0characters\u00a0that\u00a0have\u00a0odd\u00a0counts","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/generate-a-string-with-characters-that-have-odd-counts","snippet":"If n is odd, we will return a string with n 'a's. If n is even, we will return a string with n-1 'a's and one 'b'.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the number of characters in the string \nSpace complexity: <code>O(1)<\/code>"},{"title":"Inorder\u00a0successor in\u00a0BST","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/inorder-successor-in-bst","snippet":"As we are traversing a binary search tree, we can use it's property to find the inorder successor. The inorder successor of a node is the leftmost node in the right subtree. If the node does not have a right subtree, then the inorder successor is the..."},{"title":"Longest\u00a0subarray\u00a0of\u00a01s\u00a0after\u00a0deleting\u00a0one\u00a0element","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-subarray-of-1s-after-deleting-one-element","snippet":"We will use two pointers to keep track of the start and end of the subarray. We will use a variable to keep track of the number of zeros in the subarray. If the number of zeros is less than or equal to 1, we will increment the end pointer. If the number..."},{"title":"Print\u00a0immutable\u00a0linked\u00a0list\u00a0in\u00a0reverse","categories":["linked-list","stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/print-immutable-linked-list-in-reverse","snippet":"We can use a stack to store the values of the linked list. We will then pop the values from the stack and print them.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the number of nodes in the linked list \nSpace complexity: <code>O(n)<\/code>\n\nWe can achieve..."},{"title":"Reverse\u00a0words\u00a0in\u00a0a\u00a0string II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-words-in-a-string-ii","snippet":"We will reverse the entire string, then reverse each word. We will use two pointers to keep track of the start and end of each word.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of the string \nSpace complexity: <code>O(1)<\/code>"},{"title":"Valid palindrome III","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-palindrome-iii","snippet":"We will solve the problem using top-down dynamic programming. If the first and last characters are the same, we will check if the substring between the first and last characters is a valid palindrome. If the first and last characters are not the same, we..."},{"title":"Binary\u00a0tree\u00a0vertical\u00a0order\u00a0traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-vertical-order-traversal","snippet":"We will use BFS to traverse the tree. We will keep track of the horizontal distance of each node from the root. We will use a dictionary to store the nodes at each horizontal distance. We will use a queue to traverse the tree. We will use a set to keep..."},{"title":"Count\u00a0nodes\u00a0equal\u00a0to\u00a0sum\u00a0of\u00a0descendants","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-nodes-equal-to-sum-of-descendants","snippet":"We will use DFS in post order traversal to solve the problem. We will recursively call the function on the left and right child of the root. Then we will check if the sum of the left and right child is equal to the root. If it is, we will increment the..."},{"title":"Count\u00a0number\u00a0of\u00a0bad\u00a0pairs","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-number-of-bad-pairs","snippet":"Rather counting the number of bad pair, we can count the number of good pair and substruct it from to total number of pairs to get the number of bad pairs. For an array of size n, there are exactly n * (n - 1) \/ 2 unique pairs (i, j) where i &lt; j. We..."},{"title":"Count\u00a0pairs\u00a0in\u00a0two\u00a0arrays","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-pairs-in-two-arrays","snippet":"<code>nums1[i] + nums1[j] &gt; nums2[i] + nums2[j]<\/code>, i &lt; j can be converted to <code>(nums1[i]-nums2[i]) + (nums1[j]-nums2[j]) &gt; 0<\/code>, i &lt; j.\n\nAt this point, we will realize that the constrain i &lt; j is not really important anymore,..."},{"title":"Design\u00a0hashset","categories":["design","array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-hashset","snippet":"We will use a boolean array to store the values. We will use the value as the index of the array and set the value to <code>true<\/code> if the value is added and <code>false<\/code> if the value is removed.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace..."},{"title":"Design\u00a0phone\u00a0directory","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-phone-directory","snippet":"We will use a set to keep track of the available numbers. We will also use a queue to keep track of the numbers that have been released.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity: <code>O(n)<\/code>, n is the maximum number of numbers in the..."},{"title":"Find\u00a0players\u00a0with\u00a0zero\u00a0or\u00a0one\u00a0losses","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-players-with-zero-or-one-losses","snippet":"We use 3 different hashset to store zero losses, one loss and more than one loss. Then we iterate through the <code>results<\/code> array and update the hashsets accordingly. Finally, we iterate through the <code>players<\/code> array and add the players..."},{"title":"Minimize\u00a0product\u00a0sum\u00a0of\u00a0two\u00a0arrays","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimize-product-sum-of-two-arrays","snippet":"We will sort the two arrays, first one in ascending order and second one in descending order. That will make sure the product of both array's item will be minimized. Then we will iterate over the arrays and calculate the product sum. Finally, we will..."},{"title":"Remove\u00a0zero\u00a0sum\u00a0consecutive\u00a0nodes\u00a0from\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-zero-sum-consecutive-nodes-from-linked-list","snippet":"We will keep track of the prefix sum of the linked list. If the prefix sum is repeated, we will remove the nodes between the repeated prefix sum and the current prefix sum.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the number of nodes in the linked..."},{"title":"Shortest\u00a0word\u00a0distance","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-word-distance","snippet":"We will keep track of both words' last seen index. Then we will iterate through the <code>words<\/code> array and update the result if we find either of the words. Finally, we will return the result.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the number..."},{"title":"Validate\u00a0binary\u00a0tree\u00a0nodes","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/validate-binary-tree-nodes","snippet":"We will first find the root of the tree. Then we will traverse the tree and check if we can reach all the nodes from the root. We will use BFS to traverse. If we can reach all the nodes, then the tree is valid.\n\n\n\nTime complexity: <code>O(n)<\/code>..."},{"title":"Arithmetic\u00a0slices\u00a0II\u00a0subsequence","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/arithmetic-slices-ii-subsequence","snippet":"We will use dynamic programming to solve the problem. We will use a hashmap to store the number of arithmetic slices that ends with the current number. We will iterate over the numbers, and for each number, we will iterate over the numbers before the..."},{"title":"Arithmetic\u00a0slices","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/arithmetic-slices","snippet":"We will take a top-down approach to solve the problem. Then we memoize each subproblem to avoid duplicate computation.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the length of nums \nSpace complexity: <code>O(n)<\/code>"},{"title":"Binary\u00a0tree\u00a0upside\u00a0down","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-upside-down","snippet":"We will use recursive DFS to solve the problem. We will recursively call the function on the left child of the root. Then we will set the left child of the root to the right child of the root. Then we will set the right child of the root to the root...."},{"title":"Check\u00a0if\u00a0word\u00a0is\u00a0valid\u00a0after\u00a0substitutions","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-word-is-valid-after-substitutions","snippet":"We will use a stack to store the characters. We will iterate over the string. If the character is <code>a<\/code>, we will push it to the stack. If the character is <code>b<\/code>, we will check if the top of the stack is <code>a<\/code>. If it is, we will..."},{"title":"Design\u00a0browser\u00a0history","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-browser-history","snippet":"We can use a doubly linked list to store the history. We can use a pointer to point to the current node. We can use <code>visit<\/code> to add a new node to the end of the list. We can use <code>back<\/code> and <code>forward<\/code> to move the pointer to..."},{"title":"Find\u00a0smallest\u00a0common\u00a0element\u00a0in\u00a0all\u00a0rows","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-smallest-common-element-in-all-rows","snippet":"We will flatten the matrix into a single array. Then count all the elements in the array. We will get the number that appears the most in the array. If the frequency of the number is equal to the number of rows, we will return the number. Otherwise, we..."},{"title":"Maximum\u00a0number\u00a0of\u00a0coins\u00a0you\u00a0can\u00a0get","categories":["greedy","queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-coins-you-can-get","snippet":"We will use a double ended queue to store the piles. We will sort the piles in descending order. We will iterate over the piles. We will pop the first and the last element from the queue. We will add the popped elements to the result. We will return the..."},{"title":"Maximum\u00a0twin\u00a0sum\u00a0of\u00a0a\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-twin-sum-of-a-linked-list","snippet":"We will find the middle of the linked list. Then we will reverse the second half of the linked list. Then we will iterate over the first half and the second half of the linked list to find the maximum twin sum.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is..."},{"title":"Meeting\u00a0rooms\u00a0III","categories":["intervals","heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/meeting-rooms-iii","snippet":"Ready contains the ready room index for meetings. Rooms contains the rooms in use with [end_time, room_index] as element.\n\nFor [start, end] in the sorted meetings, we firstly release the rooms that is ready before start time. If there is room in ready..."},{"title":"Minimize\u00a0maximum\u00a0pair\u00a0sum\u00a0in\u00a0array","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimize-maximum-pair-sum-in-array","snippet":"We will sort the array. We will iterate over the array from the beginning and the end. We will add the first element and the last element to the result. We will return the result.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code>, n is the length of nums..."},{"title":"Next\u00a0greater\u00a0node\u00a0in\u00a0linked\u00a0list","categories":["linked-list","stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/next-greater-node-in-linked-list","snippet":"We can use a stack to store the nodes. We will iterate over the list from the end to the beginning. We will pop the nodes from the stack until the top node is greater than the current node. We will store the value of the top node in the result array. We..."},{"title":"Spiral matrix IV","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/spiral-matrix-iv","snippet":"The idea to take from this, is how to rotate the direction in a concise way. Initially we start by adding 1 to the column, and 0 to the row (going right)\n\nIf we hit a wall\/edge, we must swap the direction. The trick is to swap with: <code>xr, xc = xc,..."},{"title":"Strobogrammatic\u00a0number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/strobogrammatic-number","snippet":"We will use a lookup table to store the pairs. We will iterate over the string. If the character is not in the lookup table, we will return false. If the character is in the lookup table, we will check if the character at the other end of the string is..."},{"title":"Add\u00a0two\u00a0numbers\u00a0II","categories":["linked-list","stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-two-numbers-ii","snippet":"We can solve the problem by using stack. We will push the values of the two linked lists into two stacks. Then we will pop the values from the two stacks and add them together. If the sum is greater than 10, we will subtract 10 from the sum and carry 1..."},{"title":"Find\u00a0greatest\u00a0common\u00a0divisor\u00a0of\u00a0array","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-greatest-common-divisor-of-array","snippet":"We can solve the problem by using Euclidean algorithm. We will find the greatest common divisor of the first two numbers in the array. Then we will find the greatest common divisor of the greatest common divisor and the next number in the array. We will..."},{"title":"Sum\u00a0of\u00a0subarray\u00a0minimums","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-subarray-minimums","snippet":"We can solve it by using stack. We can iterate over the array, and for each element, we can check if the stack is empty or the top of the stack is greater than the current element. If the stack is empty or the top of the stack is greater than the current..."},{"title":"Swapping\u00a0nodes\u00a0in\u00a0a\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/swapping-nodes-in-a-linked-list","snippet":"We will iterate over the whole list to find the length of the list. Then we get the kth node as the first node and the (length-k+1)th node as the second node. We will swap the values of the two nodes.\n\n\n\nTime complexity: <code>O(n)<\/code>, n is the..."},{"title":"Complement\u00a0of\u00a0base\u00a010\u00a0integer","categories":["bit-maniuplation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/complement-of-base-10-integer","snippet":"What is the relationship between input and output? input + output = 111....11 in binary format.\nIs there any corner case? 0 is a corner case expecting 1, output > input.\n\nWe can solve it by using bit manipulation. We can use <code>~<\/code> to flip the..."},{"title":"Minimum\u00a0number\u00a0of\u00a0arrows\u00a0to\u00a0burst\u00a0balloons","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-arrows-to-burst-balloons","snippet":"We can solve it by using greedy algorithm. We can sort the balloons by the end time. We can iterate over the balloons, and for each balloon, we can check if the start time of the balloon is greater than the end time of the previous balloon. If the start..."},{"title":"Stone game VII","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stone-game-vii","snippet":"We can see dynamic programming structure in this problem: each time we take some stones from the left or from the left side, what is rest is always contigious array. So, let us denote by dp(i, j) the biggest difference in scores for the person who start..."},{"title":"The\u00a0employee\u00a0that\u00a0worked\u00a0on\u00a0the\u00a0longest\u00a0task","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/the-employee-that-worked-on-the-longest-task","snippet":"We will iterate over the logs, and for each log, we will update the start time and end time of the employee. We will also update the longest task time of the employee. After iterating over the logs, we will iterate over the employees to find the employee..."},{"title":"Broken\u00a0calculator","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/broken-calculator","snippet":"We can simulate the result. If target is greater than X, we can only multiply X by 2, otherwise we can only subtract 1 from X. So we can use greedy to find the optimal solution.\n\n\n\nTime complexity: <code>O(log(n))<\/code>, n is the value of target \nSpace..."},{"title":"Delete\u00a0duplicate\u00a0folders\u00a0in\u00a0system","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-duplicate-folders-in-system","snippet":"We will use TrieNode to create the graph of folder structure. Then dfs on our graph and serialize subtrees as strings, then add nodes which has the same serialize string into a dictionary, let name it seen. Traverse the seen dictionary, if nodes has the..."},{"title":"Final\u00a0prices\u00a0with\u00a0a\u00a0special\u00a0discount\u00a0in\u00a0a\u00a0shop","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/final-prices-with-a-special-discount-in-a-shop","snippet":"We will iterate over the prices array. For each price, we will iterate over the prices array again to find the first price that is less than or equal to the current price. If we find the price, we will subtract the price from the current price. If we..."},{"title":"Integer\u00a0to\u00a0english\u00a0words","categories":["array-and-hashmap","greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/integer-to-english-words","snippet":"We can use a hashmap to store the mapping from number to english words. Then we can use greedy to find the optimal solution.\n\n\n\nTime complexity: <code>O(log(n))<\/code>, n is the value of num \nSpace complexity: <code>O(log(n))<\/code>"},{"title":"Power\u00a0of\u00a0two","categories":["math-and-geometry","bit-maniuplation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/power-of-two","snippet":"We can solve the problem iteratively. If the number is even, we can divide it by 2. If the number is odd, we can return false. We can use bit manipulation to check if the number is odd.\n\n\n\nTime complexity: <code>O(log(n))<\/code>, n is the value of n..."},{"title":"Rabbits\u00a0in\u00a0forest","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rabbits-in-forest","snippet":"We will use a map to store the number of rabbits with the same color. Then, we will iterate through the map. For each color, we will calculate the number of groups. Then, we will add the number of groups to the result. Then, we will return the result...."},{"title":"Sliding\u00a0window\u00a0median","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sliding-window-median","snippet":"We will use a sorted list to store the numbers in the sliding window. Then, we will iterate through the list. For each number, we will find the index of the number in the sorted list. Then, we will insert the number at the index. Then, we will calculate..."},{"title":"odd-even-jump","categories":["dynamic-programming","stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/odd-even-jump","snippet":"We need to jump higher and lower alternately to the end.\n\nTake [5,1,3,4,2] as example.\n\nIf we start at 2, we can jump either higher first or lower first to the end, because we are already at the end. higher(2) = true, lower(2) = true.\n\nIf we start at 4,..."},{"title":"132\u00a0pattern","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/132-pattern","snippet":"We will use a stack to store the numbers. Then, we will iterate through the numbers and check if the number is less than the second number. If it is, then we will pop the numbers from the stack until the number is less than the second number. Then, we..."},{"title":"Boats\u00a0to\u00a0save\u00a0people","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/boats-to-save-people","snippet":"We will sort the array. Then, we will use two pointers to keep track of the start and end of the array. Then, we will iterate through the array. If the sum of the numbers at the start and end pointers is less than or equal to the limit, then we will..."},{"title":"Number\u00a0of\u00a0ways\u00a0to\u00a0paint\u00a0N\u00d73\u00a0grid","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-ways-to-paint-n-3-grid","snippet":"Two pattern for each row, 121 and 123. 121, the first color same as the third in a row. 123, one row has three different colors.\n\nWe consider the state of the first row, \npattern 121: 121, 131, 212, 232, 313, 323.\npattern 123: 123, 132, 213, 231, 312,..."},{"title":"Process\u00a0tasks\u00a0using\u00a0servers","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/process-tasks-using-servers","snippet":"We will use two heaps to simulate. The first heap will be a min heap of the servers. The second heap will be a min heap of the tasks. Then, we will iterate through the tasks. If the task is less than the current time, then we will add the server to the..."},{"title":"Random\u00a0pick\u00a0index","categories":["array-and-hashmap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/random-pick-index","snippet":"We will use a dictionary to store the indices of the numbers. Then, we will iterate through the given array and store the indices of the numbers in the dictionary. Then, we will use a random number generator to generate a random number. Then, we will..."},{"title":"Shuffle\u00a0an\u00a0array","categories":["math-and-geometry","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shuffle-an-array","snippet":"We will use a list to store the original array. Then, we will use a list to store the shuffled array. Then, we will use a random number generator to generate a random number. Then, we will swap the number at the random index with the number at the last..."},{"title":"Sort\u00a0colors","categories":["two-pointers","array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-colors","snippet":"We will use two pointers to keep track of the start and end of the array. Then, we will iterate through the array. If the number is 0, then we will swap the number at the start pointer with the number at the current index. Then, we will increment the..."},{"title":"Split\u00a0array\u00a0largest\u00a0sum","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/split-array-largest-sum","snippet":"We binary search largest sum in range [max(nums), sum(nums)], which is left = max(nums), right = sum(nums).\n\n\nmid = left + (right - left) \/\/ 2\nIf canPartition(mid) then:\n\n\nUpdate the answer so far then try to minimize the largest sum by right = mid - 1..."},{"title":"Base 7","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/base-7","snippet":"We will divide the number by 7 and keep track of the remainder. We will add the remainder to the result and multiply the result by 10. We will repeat this process until the number is 0.\n\n\n\nTime complexity: <code>O(log(n))<\/code> \nSpace complexity:..."},{"title":"Camelcase\u00a0matching","categories":["two-pointers","queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/camelcase-matching","snippet":"We will create a helper function to check if a string is a subsequence of another string. Then we will iterate over the queries and check if the query is a subsequence of the pattern. If it is, then we will append it to the result.\n\n\n\nTime complexity:..."},{"title":"design\u00a0linked\u00a0list","categories":["linked-list","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-linked-list","snippet":"We will use a stack to store the values and then do the operations on the stack."},{"title":"Linked\u00a0list\u00a0in\u00a0binary\u00a0tree","categories":["linked-list","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/linked-list-in-binary-tree","snippet":"We will traverse the tree using DFS and check if the linked list is present in the tree or not. If the linked list is present in the tree, then we will return <code>True<\/code>. Otherwise, we will return <code>False<\/code>.\n\n\n\nTime complexity:..."},{"title":"Maximum\u00a0sum\u00a0circular\u00a0subarray","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-sum-circular-subarray","snippet":"We will use Kadane's algorithm to find the maximum subarray sum. Then, we will find the minimum subarray sum and subtract it from the total sum of the array. If the total sum is greater than the maximum subarray sum, then we will return the total sum...."},{"title":"Minimum\u00a0addition\u00a0to\u00a0make\u00a0integer\u00a0beautiful","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-addition-to-make-integer-beautiful","snippet":"We will iterate through the digits of the number and find the minimum number of digits we need to add to make the number beautiful. We will keep track of the number of digits we have seen and the number of digits we need to add. If the number of digits..."},{"title":"Nearest\u00a0exit\u00a0from\u00a0entrance\u00a0in\u00a0maze","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/nearest-exit-from-entrance-in-maze","snippet":"We will start from the entrance, run BFS through the matrix and find the nearest exit. If we can't find the exit, we will return <code>-1<\/code>.\n\n\n\nTime complexity: <code>O(mn)<\/code> \nSpace complexity: <code>O(mn)<\/code>"},{"title":"Number\u00a0of\u00a0operations\u00a0to\u00a0make\u00a0network\u00a0connected","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-operations-to-make-network-connected","snippet":"We will create an adjacency list of the graph and then we will traverse the graph using DFS and count the number of connected components. If the number of connected components is greater than 1, then we will return the number of connected components..."},{"title":"Sum\u00a0of\u00a0absolute\u00a0differences\u00a0in\u00a0a\u00a0sorted\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-absolute-differences-in-a-sorted-array","snippet":"The absolute difference between two numbers a and b is:\n\n\n<code>a - b<\/code>: When a is greater than or equal to b.\n<code>b - a<\/code>: When a is less than or equal to b.\n\n\nThese cases overlap when a is equal to b, but in that case <code>a - b<\/code> and..."},{"title":"Total\u00a0cost\u00a0to\u00a0hire\u00a0k\u00a0workers","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/total-cost-to-hire-k-workers","snippet":"We will sort the workers by their quality and iterate through them. For each worker, we will add their wage to the heap and remove the highest wage if the heap size is greater than <code>k<\/code>. We will also keep track of the sum of the wages in the..."},{"title":"Vowel\u00a0spellchecker","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/vowel-spellchecker","snippet":"We will use a set to store the words in the wordlist. Then, we will use a dictionary to store the words in the wordlist with the vowels replaced with <code>*<\/code>. Then, we will iterate through the queries and check if the query is in the set. If it..."},{"title":"All\u00a0nodes\u00a0distance\u00a0k\u00a0in\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/all-nodes-distance-k-in-binary-tree","snippet":"First we will traverse the tree using DFS and create an adjacency list for each node. Then we will use BFS to find all nodes that are <code>k<\/code> distance away from the target node.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Find\u00a0all\u00a0duplicates\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-all-duplicates-in-an-array","snippet":"We will count the frequency of each number in the array, and return the numbers that appear twice.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0length\u00a0of\u00a0pair\u00a0chain","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-length-of-pair-chain","snippet":"We will first sort all the pairs by the second element. Then we will iterate over each pair and we will check if the current pair's first element is greater than the previous pair's second element. If yes, we will increment the result by 1 and update the..."},{"title":"Number\u00a0of\u00a0orders\u00a0in\u00a0the\u00a0backlog","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-orders-in-the-backlog","snippet":"We will use two heaps to keep track of the buy and sell orders. The buy orders will be stored in a max heap and the sell orders will be stored in a min heap. We will also keep track of the total number of orders in the backlog.\n\n\n\nTime complexity:..."},{"title":"Number\u00a0of\u00a0ways\u00a0to\u00a0arrive\u00a0at\u00a0destination","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-ways-to-arrive-at-destination","snippet":"We will use a priority queue to keep track of the minimum distance from the source to the destination. Then we will iterate over each node until the destination node, and we will check if the current node's distance is equal to the minimum distance. If..."},{"title":"Path\u00a0with\u00a0maximum\u00a0probability","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-with-maximum-probability","snippet":"We can use Dijkstra's algorithm to find the shortest path from the start node to the end node. We will keep track of the probability of the shortest path from the start node to the current node. Then we will iterate over each node until the end node, and..."},{"title":"Reverse\u00a0prefix\u00a0of\u00a0word","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-prefix-of-word","snippet":"We will iterate through the word and check if the current character is equal to the first character of the prefix. If it is, we will reverse the prefix and return the word.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Shopping\u00a0offers","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shopping-offers","snippet":"We can use DFS with memoization to solve this problem. We will keep track of the current state of the shopping list. Then we will iterate over each offer and we will check if the offer is valid. If yes, we will apply the offer and we will recursively..."},{"title":"Widest\u00a0vertical\u00a0area\u00a0between\u00a0two\u00a0points\u00a0containing\u00a0no\u00a0points","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/widest-vertical-area-between-two-points-containing-no-points","snippet":"We sort the points by x-coordinate, and find the maximum distance between two consecutive points.\n\n\n\nTime complexity: <code>O(nlogn)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Binary\u00a0subarrays\u00a0with\u00a0sum","categories":["array-and-hashmap","sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-subarrays-with-sum","snippet":"We can count the occurance of all the prefix sums. Then we will iterate through the prefix sums and check if the prefix sum minus the goal is in the hashmap. If yes, we will add the number of occurance of the prefix sum minus the goal to the result. We..."},{"title":"Erect\u00a0the\u00a0fence","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/erect-the-fence","snippet":"The problem is asking us to find the convex hull given a set of 2D points.\n\nMonotone Chain algorithm:\n\n\nSort the points by x. (moving from left to right)\nInitialize a stack with the first 2 points.\nStarting from the thrid point (P3) in points , P1 =..."},{"title":"Maximum\u00a0product\u00a0after\u00a0k\u00a0increments","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-product-after-k-increments","snippet":"We will use a heap to keep track of the minimum element in the array. Then we will iterate k times and we will pop the minimum element from the heap and add 1 to it. We will push the new element back to the heap. We will continue this process until we..."},{"title":"Number\u00a0of\u00a0ways\u00a0to\u00a0split\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-ways-to-split-array","snippet":"We will keep track of the left sum and right sum of the array. Then we iterate over each element until the last element, and we will check if the left sum is equal to the right sum. If yes, we will increment the result by 1. We will continue this process..."},{"title":"First\u00a0letter\u00a0to\u00a0appear\u00a0twice","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/first-letter-to-appear-twice","snippet":"We will use a hashset to keep track of the letters we have seen. If we see a letter that is already in the hashset, we return it. Otherwise we add it to the hashset.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Frog\u00a0position\u00a0after\u00a0t\u00a0seconds","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/frog-position-after-t-seconds","snippet":"We will create a adjacency list to represent the graph. We will then use a DFS to traverse the graph. We will keep track of the number of children each node has. If the node has no children, we will add the probability of reaching that node to the total..."},{"title":"Linked\u00a0list\u00a0components","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/linked-list-components","snippet":"We will create a hashset with the nums. Then we will traverse the linked list and check if the current node is in the hashset. If yes, that means both are connected. We will then traverse the linked list until we find a node that is not in the hashset...."},{"title":"Find\u00a0the\u00a0highest\u00a0altitude","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-highest-altitude","snippet":"We will iterate over the gain array and add the gain to the current altitude. We will update the maximum altitude if the current altitude is greater than the maximum altitude.\n\n\n\nWe can also achieve the same thing in one line code-\n\n\n\nTime complexity:..."},{"title":"Finding\u00a0the\u00a0users\u00a0active\u00a0minutes","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/finding-the-users-active-minutes","snippet":"We will use a hashset to count the unique logs for each user. Then we iterate over that, take the length of the hashset and add it to the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Number\u00a0of\u00a0digit\u00a0one","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-digit-one","snippet":"We will create a function <code>countDigitOne<\/code> which will take a number as input. We will initialize a variable <code>count<\/code> to <code>0<\/code>. We will initialize a variable <code>factor<\/code> to <code>1<\/code>. We will run a loop until..."},{"title":"Rectangle\u00a0area","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rectangle-area","snippet":"We will find the area of the first rectangle and the second rectangle. We will find the area of the overlapping rectangle by finding the length and breadth of the overlapping rectangle. We will subtract the area of the overlapping rectangle from the area..."},{"title":"Symmetric\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/symmetric-tree","snippet":"We will create a function <code>isMirror<\/code> which will take two nodes as input. If both the nodes are <code>None<\/code>, we will return <code>True<\/code>. If one of the nodes is <code>None<\/code>, we will return <code>False<\/code>. If the values of..."},{"title":"Construct\u00a0binary\u00a0search\u00a0tree\u00a0from\u00a0preorder\u00a0traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/construct-binary-search-tree-from-preorder-traversal","snippet":"As preorder traversal is given, we know the first element will be the root. We will create a function witg a bound the maximum number it will handle. The left recursion will take the elements smaller than <code>node.val<\/code>, the right recursion will..."},{"title":"Count\u00a0days\u00a0spent\u00a0together","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-days-spent-together","snippet":"We will use a helper function to get the number of days from the beginning of the year to the given date. Then take the maximum of arrival date and minimum of departure date and subtract the minimum of arrival date and maximum of departure date.\n\n\n\nTime..."},{"title":"Delete\u00a0nodes\u00a0and\u00a0return\u00a0forest","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-nodes-and-return-forest","snippet":"We will use DFS for deleting the nodes. We recursively delete the left and right subtrees and then return the root. If the root is in the set, we return the left and right subtrees, and if the root is not in the set, we return the root.\n\n\n\nTime..."},{"title":"Insert\u00a0into\u00a0a\u00a0binary\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/insert-into-a-binary-search-tree","snippet":"We will use DFS for inserting. We recursively insert the left and right subtrees and then return the root. If the root is null, we return the new node. If the root is greater than the value, we insert the node in the left subtree, and if the root is less..."},{"title":"Making\u00a0file\u00a0names\u00a0unique","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/making-file-names-unique","snippet":"We will use a hashmap to store the count of each file name. We will iterate over all the file names and if the file name is not present in the hashmap, we will add it to the result. If the file name is present in the hashmap, we will add the count to the..."},{"title":"Minimum\u00a0distance\u00a0to\u00a0the\u00a0target\u00a0element","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-distance-to-the-target-element","snippet":"We will iterate over all the elements and find the minimum distance.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Minimum\u00a0time\u00a0visiting\u00a0all\u00a0points","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-time-visiting-all-points","snippet":"If we go diagonally, we can reach the destination in the minimum time, actually twice as first as moving vertically and horizontally. So, we will find the maximum of the difference between the x and y coordinates and add it to the answer.\n\n\n\nTime..."},{"title":"Path\u00a0in\u00a0zigzag\u00a0labelled\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-in-zigzag-labelled-binary-tree","snippet":"We will use DFS for finding the path. We recursively find the path in the left and right subtrees and then return the root. If the root is in the set, we return the left and right subtrees, and if the root is not in the set, we return the root.\n\n\n\nTime..."},{"title":"Shortest\u00a0subarray\u00a0to\u00a0be\u00a0removed\u00a0to\u00a0make\u00a0array\u00a0sorted","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-subarray-to-be-removed-to-make-array-sorted","snippet":"We will use two pointers to find the longest subarray that is sorted. The answer will be the length of the array minus the length of the longest subarray.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Trim\u00a0a\u00a0binary\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/trim-a-binary-search-tree","snippet":"We will use DFS for trimming. We recursively trim the left and right subtrees and then return the root. If the root is less than <code>low<\/code>, we return the right subtree, and if the root is greater than <code>high<\/code>, we return the left subtree...."},{"title":"Binary\u00a0tree\u00a0tilt","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-tilt","snippet":"We will use DFS to find the tilt of each subtree and then add them together.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Count\u00a0of\u00a0matches\u00a0in\u00a0tournament","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-of-matches-in-tournament","snippet":"We can simply count the number of matches played by counting the number of times we divide the number of teams by 2. We can also count the number of teams by counting the number of times we multiply the number of teams by 2.\n\n\n\nTime complexity:..."},{"title":"Dungeon\u00a0game","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/dungeon-game","snippet":"We will solve the problem recursively and then memoize the result to avoid duplicate computation. For base case, if the knight is at the bottom right corner, then the minimum health required is 1. If the knight is at the bottom row or rightmost column,..."},{"title":"Find\u00a0duplicate\u00a0subtrees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-duplicate-subtrees","snippet":"We will use DFS and do preorder traversal to find all the subtrees. Then we can use a hash map to store the frequency of each subtree. If the frequency of a subtree is greater than 1, then we can add it to the result.\n\n\n\nTime complexity:..."},{"title":"Find\u00a0mode\u00a0in\u00a0binary\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-mode-in-binary-search-tree","snippet":"We will use a hashmap to store the frequency of each node's value. We will then traverse the hashmap and return the keys with the maximum frequency.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Longest\u00a0substring\u00a0of\u00a0all\u00a0vowels\u00a0in\u00a0order","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-substring-of-all-vowels-in-order","snippet":"We can use a sliding window and a hash set to find the longest substring of all vowels in order.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Make\u00a0two\u00a0arrays\u00a0equal\u00a0by\u00a0reversing\u00a0subarrays","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/make-two-arrays-equal-by-reversing-subarrays","snippet":"We can sort both arrays and compare them. If they are equal, then we can make the two arrays equal by reversing subarrays.\n\n\n\nTime complexity: <code>O(nlog(n))<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Maximum\u00a0area\u00a0of\u00a0a\u00a0piece\u00a0of\u00a0cake\u00a0after\u00a0horizontal\u00a0and\u00a0vertical\u00a0cuts","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts","snippet":"We will add border cuts to our horizontal and vertical cuts. Then all we need to do is consider all horizontal gaps between adjacent cuts, all vertical gaps between adjacent cuts, choose the biggest among each group and multiply them. Why it will work?..."},{"title":"Maximum\u00a0width\u00a0of\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-width-of-binary-tree","snippet":"We will use BFS to find the maximum width of the tree.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0xor\u00a0after\u00a0operations","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-xor-after-operations","snippet":"The problem calls for choosing an integer x, selecting an element n of the list, applying the compound operator op(n,x) = (x&amp;n)^n, and taking the bit-intersection of the modified set. Because of the associative and commutative properties of the XOR..."},{"title":"Most\u00a0frequent\u00a0subtree\u00a0sum","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/most-frequent-subtree-sum","snippet":"First we will use DFS to find all the subtree sum and then use a hash map to store the frequency of each subtree sum. Then we can find the most frequent subtree sum.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Path sum III","categories":["dynamic-programming","backtracking","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-sum-iii","snippet":"We will use dfs to traverse the tree and for each node, we will find the number of paths that start from the current node and have the sum equal to the target sum. We will use a hashmap to store the prefix sum and the number of times it has occurred. For..."},{"title":"Merge\u00a0strings\u00a0alternately","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-strings-alternately","snippet":"We will use 2 pointers to iterate through the 2 strings and append the characters to the result.\n\n\n\nTime complexity: <code>O(n+m)<\/code> \nSpace complexity: <code>O(n+m)<\/code>\n\nWe can use python's zip function to simplify the code:\n\n\n\nOr we can use..."},{"title":"Most\u00a0stones\u00a0removed\u00a0with\u00a0same\u00a0row\u00a0or\u00a0column","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/most-stones-removed-with-same-row-or-column","snippet":"We will create 2 adjacency list from the stones and then we will use BFS to find the connected components. The answer is the number of stones - the number of connected components.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0frequency\u00a0stack","categories":["stack","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-frequency-stack","snippet":"We will use a hashmap freq will count the frequence of elements and another hashmap stack is a map of stack. If element x has n frequence, we will push x n times in stack[1], stack[2] .. stack[n], max_freq records the maximum frequence.\n\npush(x) will..."},{"title":"Number\u00a0of\u00a0subarrays\u00a0with\u00a0bounded\u00a0maximum","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-subarrays-with-bounded-maximum","snippet":"We will use two pointers for get the range. <code>l<\/code> is the left side of our sliding window, and r is the right side of our sliding window. We increment the size of our window (we increment <code>r<\/code>) if the encountered number is >= left...."},{"title":"Leaf\u00a0similar\u00a0trees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/leaf-similar-trees","snippet":"We will run a depth-first search on both trees and compare the leaves.\n\n\n\n\n\nWe can also achieve the same result by using a python generator instead.\n\n\n\nTime Complexity: <code>O(n+m)<\/code> \nSpace Complexity: <code>O(n+m)<\/code>"},{"title":"Least\u00a0number\u00a0of\u00a0unique\u00a0integers\u00a0after\u00a0k\u00a0removals","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/least-number-of-unique-integers-after-k-removals","snippet":"We can use a heap to keep track of the frequency of each number. Then we can pop the smallest frequency from the heap until we have removed <code>k<\/code> numbers. The remaining numbers are the unique numbers.\n\n\n\nTime Complexity:..."},{"title":"Number\u00a0of\u00a0zero\u00a0filled\u00a0subarrays","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-zero-filled-subarrays","snippet":"We will iterate over each number, if the number is zero, we will add the number of subarrays that can be formed with the previous numbers to the result. We will also add the number of subarrays that can be formed with the previous numbers to the result...."},{"title":"Count\u00a0numbers\u00a0with\u00a0unique\u00a0digits","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-numbers-with-unique-digits","snippet":"For the first (most left) digit, we have 9 options (no zero); for the second digit we used one but we can use 0 now, so 9 options; and we have 1 less option for each following digits. Number can not be longer than 10 digits.\n\n\n\nTime Complexity:..."},{"title":"Removing\u00a0minimum\u00a0number\u00a0of\u00a0magic\u00a0beans","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/removing-minimum-number-of-magic-beans","snippet":"We will sort the beans. Then for each element, we will take the <code>totalSum-((arrLen-currIdx)*currNum)<\/code> and take the minimum of all such values.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Find\u00a0peak element","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-peak-element","snippet":"We will use binary search to find the peak element. We will then return the index of the peak element.\n\n\n\nTime Complexity: <code>O(log(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Maximum\u00a0nesting\u00a0depth\u00a0of\u00a0the\u00a0parentheses","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-nesting-depth-of-the-parentheses","snippet":"We will use a stack to keep track of the maximum depth of the parentheses. We will then iterate through the string and if the current character is an opening parenthesis, we will push the current depth onto the stack. Otherwise, we will pop the top of..."},{"title":"Remove\u00a0all\u00a0adjacent\u00a0duplicates\u00a0in\u00a0string II","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-all-adjacent-duplicates-in-string-ii","snippet":"We will use a stack to keep track of the characters in the string. We will then iterate through the string and if the stack is empty or the top of the stack is not equal to the current character, we will push the current character onto the stack...."},{"title":"Remove\u00a0all\u00a0adjacent\u00a0duplicates\u00a0in\u00a0string","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-all-adjacent-duplicates-in-string","snippet":"We will use a stack to keep track of the characters in the string. We will then iterate through the string and if the stack is empty or the top of the stack is not equal to the current character, we will push the current character onto the stack...."},{"title":"Score\u00a0of\u00a0parentheses","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/score-of-parentheses","snippet":"We will use a stack to keep track of the score of the parentheses. We will then iterate through the string and if the current character is an opening parenthesis, we will push the current score onto the stack. Otherwise, we will pop the top of the stack...."},{"title":"Triangle","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/triangle","snippet":"We will use recursive DFS to solve the problem. We will then iterate through the triangle and for each row, we will iterate through the row and update the current element with the minimum of the two elements below it plus the current element. We will..."},{"title":"Distribute\u00a0candies","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/distribute-candies","snippet":"We will use a set to keep track of the unique types of candies. We will then return the minimum of the length of the set and half the length of the candy array.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Online\u00a0stock\u00a0span","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/online-stock-span","snippet":"We will use a stack to keep track of the previous prices. We will then iterate over the prices and pop the stack until the top of the stack is greater than the current price. We will then push the current price and the current index onto the stack. We..."},{"title":"Average\u00a0value\u00a0of\u00a0even\u00a0numbers\u00a0that\u00a0are\u00a0divisible\u00a0by\u00a0three","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/average-value-of-even-numbers-that-are-divisible-by-three","snippet":"We will iterate over all elements and filter the numbers that are divisible by 2*3=6. Then we will calculate the average of the numbers. If there are no numbers that are divisible by 6, we will return 0.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Knight\u00a0dialer","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/knight-dialer","snippet":"We will create a DAG to represent the possible moves of the knight. We will then create a 2D array to represent the number of ways to reach a particular node. We will then iterate over the array and update the number of ways to reach the next node. We..."},{"title":"Make\u00a0the\u00a0string\u00a0great","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/make-the-string-great","snippet":"We will iterate over the string and push the characters into the stack. If the top of the stack is the same as the current character but in different cases, we will pop the top of the stack. Otherwise, we will push the current character into the stack...."},{"title":"Minimum\u00a0money\u00a0required\u00a0before\u00a0transactions","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-money-required-before-transactions","snippet":"Pick a transaction to be the very last one you perform. Before you perform this transaction, you want to perform every transaction that raises your cost, ie, every transaction where the cost is more than the cash back. Then add the cost of your chosen..."},{"title":"Pascals triangle II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pascals-triangle-ii","snippet":"We know n level pascals triangle will have n level. We will start with level 1, we put 1 there. Then we will start a loop from level 2 to level n. Then we fill up the whole level with 1. Then we loop thorugh from second element to second last element and..."},{"title":"Array\u00a0with\u00a0elements\u00a0not\u00a0equal\u00a0to\u00a0average\u00a0of\u00a0neighbors","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/array-with-elements-not-equal-to-average-of-neighbors","snippet":"We will sort the array. Then take 2 elements in pair at a time, swap their positions and then return it after the loop is finished.\n\n\n\nTime complexity: <code>O(nlogn)<\/code>\nSpace complexity: <code>O(1)<\/code>"},{"title":"Maximum\u00a069\u00a0number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-69-number","snippet":"We will iterate over all the digits of the number and check if the digit is 6. If it is, we will replace it with 9 and return the number.\n\n\n\nTime complexity: <code>O(n)<\/code>\nSpace complexity: <code>O(n)<\/code>\n\nHere is a one-liner solution:"},{"title":"Number\u00a0of\u00a0subsequences\u00a0that\u00a0satisfy\u00a0the\u00a0given\u00a0sum\u00a0condition","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-subsequences-that-satisfy-the-given-sum-condition","snippet":"We will sort the array and use two pointers to find the number of subsequences that satisfy the given sum condition.\n\n\n\nTime complexity: <code>O(nlogn)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Wiggle sort II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/wiggle-sort-ii","snippet":"We will sort the array and then split it into two halves. We will iterate over the first half and the second half and insert the elements into the result array.\n\n\n\nTime complexity: <code>O(nlogn)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Check\u00a0completeness\u00a0of\u00a0a\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-completeness-of-a-binary-tree","snippet":"We will use BFS for level order traversal. We will add children to the BFS queue, if it's a complete tree, we should not have any node once we encounter a null node.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Design\u00a0an\u00a0ordered\u00a0stream","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-an-ordered-stream","snippet":"We will use a list to store the values and a pointer to keep track of the next index to be filled. We will return the values from the pointer to the index of the current value.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Jewels\u00a0and\u00a0stones","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/jewels-and-stones","snippet":"We will count all the distinct jewels and store it in a set. Then we will iterate over all the stones and check if the stone is a jewel. If it is, we will increment the count.\n\n\n\nWe can also count all the stones and then iterate over all the jewels and..."},{"title":"Minimum\u00a0number\u00a0of\u00a0vertices\u00a0to\u00a0reach\u00a0all\u00a0nodes","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-vertices-to-reach-all-nodes","snippet":"We can just return all nodes with on incoming edge. Necesssary condition for this to work is to have all nodes with no in-degree must in the final result, because they can not be reached from. All other nodes can be reached from any other nodes. This can..."},{"title":"Orderly\u00a0queue","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/orderly-queue","snippet":"For k>1 (we just check for k=2), any two adjacent characters can be swapped: abXYZ -> abXYZ -> aXYZb -> XYZba -> YZbaX -> ZbaXY -> baXYZ. If ab are not in the beginning of the string, i.e., DEabF, we first rotate the string DEabF -> EabFD -> abFDE, then..."},{"title":"Sort\u00a0integers\u00a0by\u00a0the\u00a0number\u00a0of\u00a01\u00a0bits","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-integers-by-the-number-of-1-bits","snippet":"We will iterate over all the numbers in of the array and count the 1 bits and store it in a map. Then we will sort the map by the value and return the keys.\n\n\n\nTime complexity: <code>O(nlogn)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Counting\u00a0words\u00a0with\u00a0a\u00a0given\u00a0prefix","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/counting-words-with-a-given-prefix","snippet":"We will iterate over the words and count the number of words that start with the given prefix.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Find\u00a0all\u00a0numbers\u00a0disappeared\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-all-numbers-disappeared-in-an-array","snippet":"We will iterate over the array, and mark the element at the index of the current element as negative. Then we will iterate over the array again, and add the index of the positive element to the result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Find\u00a0pivot\u00a0index","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-pivot-index","snippet":"We will iterate over the array, and calculate the sum of the left and right side of the current index. If the sum of the left side is equal to the sum of the right side, we will return the current index.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Majority\u00a0element","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/majority-element","snippet":"We can count all element in the array, and return the element that has the most count.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0number\u00a0of\u00a0balloons","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-balloons","snippet":"We will count all the characters, then we will return the minimum of the count of <code>b<\/code>, <code>a<\/code>, <code>l<\/code>, <code>o<\/code>, and <code>n<\/code>, as the number of <code>l<\/code> and <code>o<\/code> are counted twice, we will divide the..."},{"title":"Merge\u00a0in\u00a0between\u00a0linked\u00a0lists","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-in-between-linked-lists","snippet":"We will use two pointers to find the nodes before and after the merge, and then merge the two linked lists.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Next\u00a0greater\u00a0element II","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/next-greater-element-ii","snippet":"We will iterate over the array, and push the index of the current element to the stack. If the current element is greater than the element at the top of the stack, we will pop the top of the stack, and set the element at the popped index to the current..."},{"title":"Sum\u00a0of\u00a0beauty\u00a0of\u00a0all\u00a0substrings","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-beauty-of-all-substrings","snippet":"We will follow the problem statement, and solve the problem with a brute force approach.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"The\u00a0k\u00a0strongest\u00a0values\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/the-k-strongest-values-in-an-array","snippet":"We will calture the median of the array, and then use two pointers to find the k strongest values.\n\n\n\nTime Complexity: <code>O(nlogn)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Word\u00a0pattern","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-pattern","snippet":"We will split the string to words. If the numbers of words does not match the numbers of letters in the pattern, we return false. Then we iterate over each letter in the pattern, check the position of the letter match the position of the word in the..."},{"title":"Encode\u00a0and\u00a0decode\u00a0tinyurl","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/encode-and-decode-tinyurl","snippet":"We will use two hashmaps, one for storing the code and another for storing the url. The we will create a helper function to get a random string of length 6. We will use this function to generate the code for the url. We will store the code and url in the..."},{"title":"Maximum\u00a0profit\u00a0in\u00a0job\u00a0scheduling","categories":["dynamic-programming","intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-profit-in-job-scheduling","snippet":"We will sort the jobs by their end time. Then we will iterate over the jobs, and for each job, we will find the first job that does not overlap with the current job. We will then take the maximum of the profit of the current job and the profit of the..."},{"title":"Maximum\u00a0score\u00a0from\u00a0removing\u00a0stones","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-score-from-removing-stones","snippet":"We will sort 3 numbers and remove 1 stone from the largest 2 numbers until they all become 0. The number of stones removed is the maximum score.\n\n\n\nTime complexity: <code>O(n)<\/code>, sorting 3 numbers can be done in <code>O(1)<\/code> time. \nSpace..."},{"title":"Partition\u00a0array\u00a0into\u00a0three\u00a0parts\u00a0with\u00a0equal\u00a0sum","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-array-into-three-parts-with-equal-sum","snippet":"We will calculate the sum of the array. If the sum is not divisible by 3, we return <code>False<\/code>. Otherwise, we will iterate over the array and check if the sum of the current subarray is equal to the sum of the array divided by 3. If it is, we..."},{"title":"Reverse\u00a0vowels\u00a0of\u00a0a\u00a0string","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-vowels-of-a-string","snippet":"We will iterate over the string, and if the character is a vowel, we will add it to a stack. Then we will iterate over the string again, and if the character is a vowel, we will pop the stack and add it to the result. If the character is not a vowel, we..."},{"title":"Longest\u00a0palindrome\u00a0by\u00a0concatenating\u00a0two\u00a0letter\u00a0words","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-palindrome-by-concatenating-two-letter-words","snippet":"We can use a hashmap to store the frequency of each word. Then we can iterate over the words and check if the reverse of the word is present in the hashmap. If it is, we add the frequency of the word and the reverse of the word to the result.\n\n\n\nTime..."},{"title":"Smallest\u00a0good\u00a0base","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/smallest-good-base","snippet":"First we will convert the string to a integer. Then we calculate the maximum number of digits that the base can have. We will iterate from the maximum number of digits to 2. For each number of digits, we will calculate the base. If the base is a valid..."},{"title":"Count\u00a0items\u00a0matching\u00a0a\u00a0rule","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-items-matching-a-rule","snippet":"We will iterate over the items and check if the rule matches. If it does, we increment the count.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Intersection\u00a0of\u00a0two\u00a0arrays","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/intersection-of-two-arrays","snippet":"We can use 2 sets to store the elements of each array. Then we can iterate over the elements of the first set and check if it is present in the second set. If it is, we add it to the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Largest\u00a03\u00a0same\u00a0digit\u00a0number\u00a0in\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-3-same-digit-number-in-string","snippet":"We will start from 9 till 0 and try to find the largest 3 same digit number in the string. If we find it, we return it. Otherwise, we return empty string.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Minimum\u00a0absolute\u00a0difference\u00a0in\u00a0bst","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-absolute-difference-in-bst","snippet":"We will traverse the tree with inorder traversal, that way we will get a sorted array. We will keep track of the minimum difference between two consecutive elements in the array, return it as the result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Minimum\u00a0swaps\u00a0to\u00a0group all 1s together II","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-swaps-to-group-all-1s-together-ii","snippet":"We will count number of ones in nums, let the number of ones be stored in the variable <code>ones<\/code>. Append nums to nums because we have to look at it as a circular array. Find the maximum number of ones in a window of size ones in the new array...."},{"title":"Where will the ball fall","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/where-will-the-ball-fall","snippet":"We drop the ball at grid[0][c] and track ball position c1, which initlized as c. An observation is that,\nif the ball wants to move from c1 to c2, we must have the board direction grid[r][c1] == grid[r][c2].\n\n\n\nTime complexity: <code>O(r*c)<\/code> \nSpace..."},{"title":"Find\u00a0all\u00a0possible\u00a0recipes\u00a0from\u00a0given\u00a0supplies","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-all-possible-recipes-from-given-supplies","snippet":"We will create a graph where each node represents a recipe and each edge represents a supply. We will iterate over the recipes and add the edges to the graph. We will use topological sort to solve the dependencies in the graph. We will iterate over the..."},{"title":"Optimal\u00a0division","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/optimal-division","snippet":"Regardless of parentheses, every element is either in the numerator or denominator of the final fraction. The expression nums[0] \/ ( nums[1] \/ nums[2] \/ ... \/ nums[n-1] ) has every element in the numerator except nums[1], and it is impossible for nums[1]..."},{"title":"Pairs\u00a0of\u00a0songs\u00a0with\u00a0total\u00a0durations\u00a0divisible\u00a0by\u00a060","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pairs-of-songs-with-total-durations-divisible-by-60","snippet":"Calculate the time % 60 then it will be exactly same as two sum problem.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Toeplitz\u00a0matrix","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/toeplitz-matrix","snippet":"We will iterate over the rows and columns and compare diagonally adjacent elements. If they are not equal, we can return false. If we reach the end of the loop, we can return true.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity:..."},{"title":"Divide\u00a0array\u00a0into\u00a0equal\u00a0pairs","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/divide-array-into-equal-pairs","snippet":"We can use a hashmap to store the frequency of each element in the array. Then we can iterate over the array and check if the frequency of the current element is even or not. If it is even, we can divide it by 2 and add it to the result. If it is odd, we..."},{"title":"Shortest\u00a0path\u00a0in\u00a0a\u00a0grid\u00a0with\u00a0obstacles\u00a0elimination","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-path-in-a-grid-with-obstacles-elimination","snippet":"We will use a queue to store the nodes that we need to visit. We will also use a set to store the nodes that we have already visited. We will traverse the grid in a breadth-first manner. If the current node is equal to the destination node, then we will..."},{"title":"Valid\u00a0number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-number","snippet":"We cal also use 3 flags for met_dot, met_e and met_digit. We can iterate over the string and update the flags. If the current character is a digit, we can set met_digit to true. If the current character is a dot, we can set met_dot to true. If the..."},{"title":"Earliest\u00a0possible\u00a0day\u00a0of\u00a0full\u00a0bloom","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/earliest-possible-day-of-full-bloom","snippet":"We can be greedy about the solution. We need to plant the flower that takes longest possible time to grow the earliest. So, we will sort the flowers in descending order of their grow time. Then we will plant them one by one and check if we can bloom all..."},{"title":"Most\u00a0frequent\u00a0number\u00a0following\u00a0key\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/most-frequent-number-following-key-in-an-array","snippet":"We will use a hashmap to store the frequency of each number. Then we will traverse the array and check if the current number is equal to the key. If it is, then we will increment the frequency of the next number. We will return the number with the..."},{"title":"Search\u00a0in\u00a0a\u00a0binary\u00a0search\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-in-a-binary-search-tree","snippet":"We will traverse the tree in a depth-first manner. If the current node's value is equal to the target value, then we will return the current node. If the current node's value is greater than the target value, then we will search in the left subtree. If..."},{"title":"All\u00a0elements\u00a0in\u00a0two\u00a0binary\u00a0search\u00a0trees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/all-elements-in-two-binary-search-trees","snippet":"We will inorder traverse both tree to get the sorted list of elements in both trees. We will merge the two sorted lists into one sorted list.\n\n\n\nTime complexity: <code>O(n1+n2)<\/code>, n1 and n2 are the number of nodes in the tree \nSpace complexity:..."},{"title":"Fruit\u00a0into\u00a0baskets","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/fruit-into-baskets","snippet":"We will use a sliding window to keep track of the fruits in the current basket. We will keep track of the last fruit we have seen and the number of times we have seen it. If the current fruit is the same as the last fruit, we will increment the count. If..."},{"title":"Integer\u00a0replacement","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/integer-replacement","snippet":"We will follow the problem statement, and solve it recursively. Then we will memoize the result to avoid repeated computations.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(n)<\/code>"},{"title":"Max\u00a0consecutive ones III","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-consecutive-ones-iii","snippet":"We basically need to find the longest subarray with at most k zeros. We can use the sliding window technique to get that.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Max\u00a0consecutive\u00a0ones","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-consecutive-ones","snippet":"We will count the number of consecutive ones and update the result if it is greater than the current result.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Replace\u00a0the\u00a0substring\u00a0for\u00a0balanced\u00a0string","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/replace-the-substring-for-balanced-string","snippet":"We will use a sliding window to keep track of the number of characters in the current substring. We will keep track of the number of characters we need to replace. We will keep track of the minimum length of the substring we need to replace.\n\n\n\nTime..."},{"title":"Sum\u00a0of\u00a0number\u00a0and\u00a0its\u00a0reverse","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-number-and-its-reverse","snippet":"We will try every number till the original given number, reverse the number and add it to the original number.\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Count\u00a0good\u00a0numbers","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-good-numbers","snippet":"There are 5 possibilities for even positions(0, 2, 4, 6, 8) and 4 for odd positions(2, 3, 5, 7). Therefore the answer for every n is 5^number of even places * 4^number of odd places.\n\n\n\nTime complexity: <code>O(1)<\/code> \nSpace complexity:..."},{"title":"Image\u00a0overlap","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/image-overlap","snippet":"We will convert the two images into a list of coordinates. Then we will iterate over all possible shifts and count the number of overlapping coordinates. The maximum number of overlapping coordinates will be the answer.\n\n\n\nTime complexity: O(n^2) \nSpace..."},{"title":"Predict\u00a0the\u00a0winner","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/predict-the-winner","snippet":"We will take the maximum of the two possible choices for the current player. If the current player chooses the leftmost element, the next player will choose the maximum of the two possible choices for the next player. If the current player chooses the..."},{"title":"XOR\u00a0queries\u00a0of\u00a0a subarray","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/xor-queries-of-a-subarray","snippet":"We will in-place calculate the prefix XOR of input array. For each query [i, j], if i == 0, query result = array[j], if i != 0, query result = array[i-1] ^ array[j].\n\n\n\nTime complexity: <code>O(n)<\/code> \nSpace complexity: <code>O(1)<\/code>"},{"title":"Groups\u00a0of\u00a0special\u00a0equivalent\u00a0strings","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/groups-of-special-equivalent-strings","snippet":"We will take each word, separate the even and odd characters, and sort them. Then we add them to a set. The size of the set is the number of groups.\n\n\n\nTime Complexity: <code>O(n*klog(k))<\/code>, n is the number of words, k is the lenght of longest word..."},{"title":"Kth\u00a0missing\u00a0positive\u00a0number","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-missing-positive-number","snippet":"The first idea we can think of when we look at this problem is just to traverse elements 1, 2, 3, ... and find missing element with index k. To make it efficient, we create arr_set: set of all numbers Iterate i from 1 to k + len(arr): it will be enough..."},{"title":"Longest\u00a0uploaded\u00a0prefix","categories":["heap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-uploaded-prefix","snippet":"We will use a longest flag and a list to store all the videos. Since the prefix cannot decrease, it is enough for us to increase it until we reach the number that has not yet been added. We will iterate all videos. For each video, we will check if the..."},{"title":"Maximum\u00a0number\u00a0of\u00a0pairs\u00a0in array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-number-of-pairs-in-array","snippet":"We will count the frequency of each number in the array. Then we iterate the frequency map and count the number of pairs.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Minesweeper","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minesweeper","snippet":"We will run a DFS on the grid and return the number of mines adjacent to the cell if the cell is not a mine. Otherwise, we will return 'X' and mark the cell as visited.\n\n\n\nTime complexity: O(n^2) \nSpace complexity: O(1)"},{"title":"Shortest\u00a0bridge","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shortest-bridge","snippet":"We will first scan the grid to find the first island and mark it with 2 after exploring it with DFS. Then we will start a BFS from the first island and explore the grid to find the second island. We will mark the cells of the first island with 3 to avoid..."},{"title":"Check\u00a0if\u00a0two\u00a0string\u00a0arrays\u00a0are\u00a0equivalent","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-two-string-arrays-are-equivalent","snippet":"We will join the two arrays to strings and check if they are equal.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Escape\u00a0the\u00a0ghosts","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/escape-the-ghosts","snippet":"We will calculate the Manhattan distance between the ghost and the target. If the ghost is closer to the target than the player, we will return <code>False<\/code>. Otherwise, we will return <code>True<\/code>.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Reverse\u00a0odd\u00a0levels\u00a0of\u00a0binary\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-odd-levels-of-binary-tree","snippet":"we will use preorder traversal to reverse the odd levels of the tree.\n\n\n\nTime complexity: O(n), where n is the number of nodes in the tree. \nSpace complexity: O(h) where h is the height of the tree"},{"title":"Serialize\u00a0and\u00a0deserialize\u00a0bst","categories":["tree","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/serialize-and-deserialize-bst","snippet":"we will use preorder traversal to serialize the tree. Then we will use the preorder traversal to deserialize the tree as well.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Maximum\u00a0length\u00a0of\u00a0a\u00a0concatenated\u00a0string\u00a0with\u00a0unique\u00a0characters","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-length-of-a-concatenated-string-with-unique-characters","snippet":"We will use a set to filter out the strings with duplicate characters. Then we iterate over each sting and check if it has duplicate characters. If not, we will add it to the set. Then we will iterate over all the strings in the set and check if the..."},{"title":"Open\u00a0the\u00a0lock","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/open-the-lock","snippet":"We will use a queue to store the current state of the lock. Then we will iterate over the queue and check if the current state is the target state. If not, we will iterate over each digit and check if we can move the digit forward or backward. If yes, we..."},{"title":"Can\u00a0place\u00a0flowers","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/can-place-flowers","snippet":"We will assume the first and last position are not occupied, so we will imagine 2 empty position at both boundary. Then we will iterate the array and check if the current position is empty and the previous and next positions are occupied. If so, we will..."},{"title":"Integer\u00a0break","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/integer-break","snippet":"We will use dynamic programming to solve this problem. We will create an array <code>dp<\/code> with size <code>n+1<\/code>. <code>dp[i]<\/code> will store the maximum product we can get by breaking <code>i<\/code> into two or more integers. We will iterate..."},{"title":"Set\u00a0mismatch","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/set-mismatch","snippet":"The sum of all numbers in the array is <code>n*(n+1)\/2<\/code>. We calculate all the numbers in the array and subtract it from the sum. The result is the missing number. We will subtract the sum of all numbers in the array from the sum of all numbers from..."},{"title":"Destination city","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/destination-city","snippet":"The destination city can not be seen as departure city. So, we will create a set with all departure cities. Then we iterate all destination cities and check if it is in the set. If not, we return it.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Minimum\u00a0number\u00a0of\u00a0operations\u00a0to\u00a0convert\u00a0time","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-operations-to-convert-time","snippet":"We will convert the time to minutes. Then we will calculate the difference between the target time and the current time. If the difference is negative, we will add 24 hours to it. Then we will calculate the number of hours and minutes we need to change...."},{"title":"Contains duplicate II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/contains-duplicate-ii","snippet":"We will use a hashmap to store the last index of each number. For each number, we will check if the difference between the current index and the last index is less than or equal to k. If it is, then we will return true. Otherwise, we will update the last..."},{"title":"Isomorphic\u00a0strings","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/isomorphic-strings","snippet":"We can iterate over both string at the same time and look for the first occurrence of each character. If the first occurrence of the character in both strings is not the same, then we will return false. Otherwise, we will return true.\n\n\n\nTime Complexity:..."},{"title":"Unique\u00a0email\u00a0addresses","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-email-addresses","snippet":"We will iterate over the emails and split them into the local name and the domain name. We will then remove all the dots from the local name and remove everything after the first plus sign. We will then add the local name and the domain name to a set...."},{"title":"Maximum\u00a0points\u00a0you\u00a0can\u00a0obtain\u00a0from\u00a0cards","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-points-you-can-obtain-from-cards","snippet":"We will use two pointers to keep track of the maximum points we can obtain. We will start with the first k cards and the last k cards. Then we will move the pointers to the right and left and check if the sum of the cards we have is greater than the..."},{"title":"Number\u00a0of\u00a0valid\u00a0move\u00a0combinations\u00a0on\u00a0chessboard","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-valid-move-combinations-on-chessboard","snippet":"We will simulate the solution, using a set to store the positions and then traverse through each possible position with a DFS and backtrack if we don't find a valid position.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity: <code>O(n^2)<\/code>"},{"title":"Map\u00a0sum\u00a0pairs","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/map-sum-pairs","snippet":"We will take a trie and a map. The map will store the key and the value. The trie will store the sum of all the values of the keys that start with the current prefix. We will iterate over all the keys and insert them in the trie. For inserting a key, we..."},{"title":"Minimum\u00a0operations\u00a0to\u00a0halve\u00a0array\u00a0sum","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-operations-to-halve-array-sum","snippet":"We will compute the half of the sum of the input nums, put all nums into a max heap. Then pull out and cut the current max value by half and add it back to heap, deduct the half of the sum accordingly and increase the counter ops by 1. Repeat it utill..."},{"title":"Queries\u00a0on\u00a0a\u00a0permutation\u00a0with\u00a0key","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/queries-on-a-permutation-with-key","snippet":"We will do the simulation. Fist we will create a list with all the permutation. For each query, we will find the index of the query value in the permutation, then we will move the value to the front of the permutation and add the index to the result...."},{"title":"Short\u00a0encoding\u00a0of\u00a0words","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/short-encoding-of-words","snippet":"We can find similar suffixes by reversing each word and adding it to our trie. Then, we can perform DFS on the tree-like structure to obtain all maximum-length chains; i.e., words that are not suffixes.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Reduction\u00a0operations\u00a0to\u00a0make\u00a0the\u00a0array\u00a0elements\u00a0equal","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reduction-operations-to-make-the-array-elements-equal","snippet":"We will sort the array in descending order, then iterate over the array and count the number of elements that are less than the current element. Finally return the sum of the counts.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity:..."},{"title":"Best\u00a0sightseeing\u00a0pair","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-sightseeing-pair","snippet":"Count the current best score in all previous sightseeing spot. Note that, as we go further, the score of previous spot decrement.\n\ncur will record the best score that we have met. We iterate each value a in the array and update the result with the..."},{"title":"Convert\u00a0binary\u00a0number\u00a0in\u00a0a\u00a0linked\u00a0list\u00a0to\u00a0integer","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-binary-number-in-a-linked-list-to-integer","snippet":"We will use a variable <code>res<\/code> to store the result. We will iterate over the linked list, and for each node, we will shift <code>res<\/code> to the left by 1 bit, and add the value of the current node to <code>res<\/code>. Finally, we will return..."},{"title":"Delete\u00a0leaves\u00a0with\u00a0a\u00a0given\u00a0value","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-leaves-with-a-given-value","snippet":"We will use recursion to solve this problem. If the current node is a leaf and its value is the target value, we will return <code>None<\/code>. Otherwise, we will recursively call the function on the left and right child. If the left child is..."},{"title":"Find\u00a0numbers\u00a0with\u00a0even\u00a0number\u00a0of\u00a0digits","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-numbers-with-even-number-of-digits","snippet":"Given an array <code>nums<\/code> of integers, return how many of them contain an even number of digits. We will use a helper function to count the number of digits of each number. Then iterate over each number, count their digit, and check if it is..."},{"title":"Minimum\u00a0difficulty\u00a0of\u00a0a\u00a0job\u00a0schedule","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-difficulty-of-a-job-schedule","snippet":"We will apply DFS to find the the minimum difficulty if start work at ith job with <code>d<\/code> days left. If d = 1, only one day left, we have to do all jobs, return the maximum difficulty of jobs. Then we will use memoization to store the result of..."},{"title":"String compression II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/string-compression-ii","snippet":"Start from the beginning of the s, you would meet two situations:\n\n\nThe next character is the same as the last one, e.g. \"aaa\" with the next one still \"a\". The former characters would be \"a3\", so you need to combine them and make it \"a4\"\nThe total length..."},{"title":"Delete\u00a0the\u00a0middle\u00a0node\u00a0of\u00a0a\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-the-middle-node-of-a-linked-list","snippet":"We will take a two pointer approach to find the middle node, and then we will delete the middle node. The first pointer will move one step at a time, and the second pointer will move two steps at a time. When the second pointer reaches the end of the..."},{"title":"Find\u00a0missing\u00a0observations","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-missing-observations","snippet":"We are given an array of <code>n<\/code>\u00a0integers. We are also given <code>m<\/code>\u00a0missing values. We need to find all the possible values that can be assigned to the missing values such that the sum of the array becomes <code>totalSum<\/code>.\n\nWe will..."},{"title":"Find\u00a0positive\u00a0integer\u00a0solution\u00a0for\u00a0a\u00a0given\u00a0equation","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-positive-integer-solution-for-a-given-equation","snippet":"Given a\u00a0function\u00a0<code>f(x, y)<\/code>\u00a0and a value\u00a0<code>z<\/code>, return all positive integer\u00a0pairs\u00a0<code>x<\/code>\u00a0and\u00a0<code>y<\/code>\u00a0where\u00a0<code>f(x,y) == z<\/code>. Rephrase the problem like given a matrix, each row and each column is..."},{"title":"Shift\u00a02d\u00a0grid","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/shift-2d-grid","snippet":"We are given a 2d grid of size <code>m x n<\/code>\u00a0and an integer <code>k<\/code>. We need to shift the grid\u00a0<code>k<\/code>\u00a0times. In one shift operation, we shift the grid by one cell to the right. For example, if the grid is..."},{"title":"Determine\u00a0whether\u00a0matrix\u00a0can\u00a0be\u00a0obtained\u00a0by\u00a0rotation","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/determine-whether-matrix-can-be-obtained-by-rotation","snippet":"We will rotate the matrix 4 times and check if it is equal to the target matrix.\n\n\n\nTime complexity: O(n^2) \nSpace complexity: O(n^2)"},{"title":"Largest\u00a0perimeter\u00a0triangle","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-perimeter-triangle","snippet":"We will sort the array in descending order and check if the sum of the first three numbers is greater than the sum of the next three numbers. If it is, we return the sum of the first three numbers. Otherwise, we return the sum of the next three numbers...."},{"title":"Increasing\u00a0triplet\u00a0subsequence","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/increasing-triplet-subsequence","snippet":"We will keep track of the smallest and second smallest number in the array. If we find a number that is greater than both, we return true. Otherwise, we return false.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Number\u00a0of\u00a0recent\u00a0calls","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-recent-calls","snippet":"We will use a queue to store the recent calls. We will remove the calls that are not in the range of 3000ms. Then we will return the size of the queue.\n\n\n\nTime complexity: O(n) \nSpace complexity: O(n)"},{"title":"Break\u00a0a\u00a0palindrome","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/break-a-palindrome","snippet":"We can check the half of the string and if a character is not a, we can replace it with a. If all characters are a, we can replace the last character with b. If the string is a single character, we can return an empty string.\n\n\n\nTime complexity: O(n)..."},{"title":"Convert\u00a0bst\u00a0to\u00a0greater\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-bst-to-greater-tree","snippet":"We will iterate over the tree in reverse inorder and keep track of the sum of all the nodes we have traversed so far. We will add the sum to the current node and update the sum with the current node value.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Find\u00a0bottom\u00a0left\u00a0tree\u00a0value","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-bottom-left-tree-value","snippet":"We will traverse the tree with BFS and assign the first node of the each level in our result. At the end of the traversal, we will return the result, which will store the left most value of the last level of the tree.\n\n\n\nTime Complexity:..."},{"title":"Flip\u00a0equivalent\u00a0binary\u00a0trees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flip-equivalent-binary-trees","snippet":"We will start traversing both tree with DFS and check whether the left subtree and right subtree are equal for both tree or left subtree is equal to right subtree and vice-versa both tree.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Frequency\u00a0of\u00a0the\u00a0most\u00a0frequent\u00a0element","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/frequency-of-the-most-frequent-element","snippet":"First we will sort the array. Then it turns into a sliding window problem, the key is to find out the valid condition k + sum >= size * max. For every new element nums[r] to the sliding window, add it to the sum by sum += nums[r]. Check if it'a valid..."},{"title":"Guess\u00a0number\u00a0higher\u00a0or\u00a0lower","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/guess-number-higher-or-lower","snippet":"This is a classic binary search problem. We will use binary search to find the number. We will use provided <code>guess<\/code> function to check whether the number is equal to the target or not.\n\n\n\nTime Complexity: <code>O(log(n))<\/code> \nSpace..."},{"title":"Two\u00a0sum\u00a0IV\u00a0input\u00a0is\u00a0a\u00a0bst","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/two-sum-iv-input-is-a-bst","snippet":"This is very similar to two sum problem. But rather than traversing an array, we will traverse a tree. We will be using DFS to traverse the tree and along with the way, we will store the difference between the target and current node value into a lookup..."},{"title":"Find\u00a0all\u00a0anagrams\u00a0in\u00a0a\u00a0string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-all-anagrams-in-a-string","snippet":"We will use counter to calculate the number of characters of string p. Then we take a sliding window of lenght p, then compare the character count with the character count of p. If we found a match, we append the starting index in the result. We will..."},{"title":"Find\u00a0the\u00a0index\u00a0of\u00a0the\u00a0first\u00a0occurrence\u00a0in\u00a0a\u00a0string","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-index-of-the-first-occurrence-in-a-string","snippet":"We will create a substring of length of the needle and compare it with the needle, if we find a match, we return the index as result, otherwise return -1.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>\n\nWe can use python's..."},{"title":"Remove element","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-element","snippet":"We will take a pointer at the beginning of the array, then iterate over the whole array. If the value doesn't match the given values, we assing it to the pointer's position of the array and then forward it position. Finally return the pointer position as..."},{"title":"Unique\u00a0length\u00a03\u00a0palindromic\u00a0subsequences","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-length-3-palindromic-subsequences","snippet":"For each palindromes in format of \"aba\", we enumerate the character on two side. We find its first occurrence and its last occurrence, all the characters in the middle are the candidate for the middle char.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Reverse\u00a0linked\u00a0list II","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-linked-list-ii","snippet":"First if the left and right position of the list is same, we can just return the list. Otherwise, we will take a pointer, traverse till the left position, then reverse the list in place till the right position. Once the reversal of the list is done, we..."},{"title":"Search\u00a0insert\u00a0position","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-insert-position","snippet":"This one is the classic binary search problem. We will strat looking for the target, if we find the target then we insert on that position. If we don't find the target, then we insert at the last low pointer position, beacuse that is the place it is most..."},{"title":"Single\u00a0threaded\u00a0cpu","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/single-threaded-cpu","snippet":"First we sort the tasks according to start time, remember to keep a reference to the original task index. Set the current time to the first start time in the task list. Push all tasks whose start time is less than or equals to the current time into heap...."},{"title":"Baseball\u00a0game","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/baseball-game","snippet":"We will use a stack to add the input and from there we will just follow the problem statement instruction. Finally we will return the sum of stack itself as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Is\u00a0subsequence","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/is-subsequence","snippet":"We will take two pointers, and then go through both string and increase the number of the pointers. When we exit the loop, if the pointer value of the first pointer is equal to the lenght of the first sting, we return true otherwise false.\n\n\n\nTime..."},{"title":"Length\u00a0of\u00a0last\u00a0word","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/length-of-last-word","snippet":"We will first start from the end and move the end pointer till we find a character. Then we take another pointer beginning from the end character and move towards the beginning of the string until we find an empty character. Then return the difference..."},{"title":"Longest\u00a0common\u00a0prefix","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-common-prefix","snippet":"We will take the shortest string as the shortest at the beginning. Then we iterate over each character of the shortest string, and match with the other strings, if the character doesn't match, we return the slice of the shortest string till that..."},{"title":"Merge\u00a0two\u00a0binary\u00a0trees","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-two-binary-trees","snippet":"We will start form the root and run a DFS with both the tree and merge their value to the new tree and return that new tree as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Replace\u00a0elements\u00a0with\u00a0greatest\u00a0element\u00a0on\u00a0right\u00a0side","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/replace-elements-with-greatest-element-on-right-side","snippet":"We will take the initial greatest element as -1. Then we start from the end of the array, replace the value with the greatest element and update the greatest element with the maximum of the greatest element and the current element. When we reach the..."},{"title":"Add\u00a0one\u00a0row\u00a0to\u00a0tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-one-row-to-tree","snippet":"We will recursively traverse the tree, and when we reach the level of the given depth, we insert nodes on both left and right subtree and return the value.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Add\u00a0binary","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-binary","snippet":"We will start from the end character of each number, add that and if the sum is more than 2, we take the reminder to the next digit, and add the last digit to our result. We will continue the process until the beginning of both number.\n\n\n\nTime..."},{"title":"Delete\u00a0node\u00a0in\u00a0a\u00a0linked\u00a0list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-node-in-a-linked-list","snippet":"As we are not given with head node, we will copy the value of next node to the current node. Then we remove the next node by moving the next pointer of current node to the next pointer of the next node.\n\n\n\nTime Complexity: <code>O(1)<\/code> \nSpace..."},{"title":"N-queens II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-queens-ii","snippet":"We will have 3 different sets, one for the column, one for positive diagonal and one for negative diagonal. We will iterate over the each row, and try to add the queen in the board. If this is already in either of the 3 sets, then we continue to the next..."},{"title":"Palindrome\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/palindrome-number","snippet":"We can convert the number to string, reverse it and then check whether it's palindrome of not.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>\n\nFirst of all it the number is negative or the last digit of the number is 0, then..."},{"title":"Remove\u00a0covered\u00a0intervals","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-covered-intervals","snippet":"We will sort the intervals by start with ascending order and end at decending order. Then we iterate over each intervals, if the end is greater than a right value, which is initially set as 0, then we add it to the result and replace the end with maximum..."},{"title":"Ugly\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/ugly-number","snippet":"If the number is negative, then it's not a ugly number. Then we do exactly what the problem statement says, we divide the number by 2, 3 and 5 until we can't divide it any more with these numbers. If the remainder is 1, then it's an ugly number.\n\n\n\nTime..."},{"title":"Asteroid\u00a0collision","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/asteroid-collision","snippet":"We will take a stack and iterate over all the elements. If the element is positive, we append it on the stack. Else we take the number, check the value of the number. If it is equal to the top of the stack, we pop both of them. If it is greater, we..."},{"title":"Minimum\u00a0time\u00a0to\u00a0make\u00a0rope\u00a0colorful","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-time-to-make-rope-colorful","snippet":"For a group of continuous same characters, we need to delete all the group but leave only one character. For each group of continuous same characters, we need cost = sum_cost(group) - max_cost(group).\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Minimum\u00a0difference\u00a0between\u00a0highest\u00a0and\u00a0lowest\u00a0of\u00a0k\u00a0scores","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-difference-between-highest-and-lowest-of-k-scores","snippet":"We will first sort the elements and then loop over all the elements and take the difference between k elements, and keep a running minimum and then return that as result.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Move\u00a0zeroes","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/move-zeroes","snippet":"We will take a simple two pointers approach, the left will be the first index. Then we iterate over the array, and every time we find a zero, we change the position of it with the next character until we reach the end or another zero.\n\n\n\nTime Complexity:..."},{"title":"Number\u00a0of\u00a0dice\u00a0rolls\u00a0with\u00a0target\u00a0sum","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-dice-rolls-with-target-sum","snippet":"We will take the brute force method to solve the problem, in every iteration till n, we will take 1 to k elements and add it to our total recursively. Then when we reach the target, we will add it to our result. Then we will return the result by modding..."},{"title":"Rotate\u00a0array","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rotate-array","snippet":"This approach is based on the fact that when we rotate the array k times, k%nk elements from the back end of the array come to the front and the rest of the elements from the front shift backwards.\n\nIn this approach, we firstly reverse all the elements..."},{"title":"Intersection\u00a0of\u00a0two\u00a0linked\u00a0lists","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/intersection-of-two-linked-lists","snippet":"We start from both list together, and if we can't find a match, we change the position of the both list, and continue until we find a match and return that.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Merge\u00a0sorted\u00a0array","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-sorted-array","snippet":"We would love to work through nums1 and nums2 starting at index 0 and going to the end of each array, comparing them element by element, but because the first m elements of nums1 are important, we might accidentally overwrite them. So, how can we avoid..."},{"title":"Reverse\u00a0string","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-string","snippet":"We will take 2 pointers, one at the beginning and one at the end of the string. Then we swap their position and move to the next character. Once these two pointers meet, we stop.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Valid\u00a0palindrome\u00a0II","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-palindrome-ii","snippet":"We will take two pointers, one at the beginning and one at the end. Then we start compare, if it doesn't match, then we try to skip the character in the left pointer and character in right pointer and check whether the rest is palindrome or not and..."},{"title":"Destroying\u00a0asteroids","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/destroying-asteroids","snippet":"We can sort the arstroids and greedy simulate the process described in the problem statement. If at any point the mass is less that the asteroid, then we return false, otherwise if we can finish iterating over every asteroid, then we return true.\n\n\n\nTime..."},{"title":"Dota2\u00a0senate","categories":["greedy","queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/dota2-senate","snippet":"We will take 2 queues one for dire and one for radiants which keeps their indexes. We pop from both queue whichever is larger(y) index we will bann that. and append smaller_element (x)+ idx as this element will be candidate for next round.\n\n\n\nTime..."},{"title":"Reveal\u00a0cards\u00a0in\u00a0increasing\u00a0order","categories":["queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reveal-cards-in-increasing-order","snippet":"we will first sort the deck in descending order. Then we iterate over each card of the deck and append it to a queue. And before appending, if the queue is not empty, then we pop the card from the queue and append it back, so basically rotating the card...."},{"title":"Word break II","categories":["trie","backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-break-ii","snippet":"We will use backtracking to find all possible word match from our word dictionary and add that to our result array and finally return it.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Design\u00a0front\u00a0middle\u00a0back\u00a0queue","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-front-middle-back-queue","snippet":"We will use 2 queue, both of them will have half of the elements. One queue must not be bigger than 1 element. Every time we add and remove an element, we will balance both the queue.\n\n\n\nTime Complexity: <code>O(1)<\/code> for each operation \nSpace..."},{"title":"Find\u00a0the\u00a0winner\u00a0of\u00a0the\u00a0circular\u00a0game","categories":["queue"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-winner-of-the-circular-game","snippet":"We can use a queue and add all the numbers to the queue and then remove every kth element. Then when just one item is left in the queue, we return that item.\n\n\n\nTime Complexity: <code>O(n*k)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Flood\u00a0fill","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flood-fill","snippet":"We will start from the source row and column and visit all connected position with the same color using DFS and color them with our new color. We will keep a visited set to avoid repetation of the same grid position twice.\n\n\n\nTime Complexity:..."},{"title":"Product\u00a0of\u00a0the\u00a0last\u00a0k\u00a0numbers","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/product-of-the-last-k-numbers","snippet":"We will calculate the prefix product while adding number to the queue. Then while getting the product, we will divive the last item with the last kth item to get the product of last k elements.\n\n\n\nTime Complexity: <code>O(1)<\/code> for each operation..."},{"title":"Bulb\u00a0switcher","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/bulb-switcher","snippet":"Basically, if bulb A has an odd number of factors, then that bulb will be on in the end because each bulb is off at the start. If bulb Ahas an even number of factors, then that bulb will be off in the end because each bulb is off at the start. The only..."},{"title":"Design\u00a0circular\u00a0deque","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-circular-deque","snippet":"We can use a deque from the collections in python, and use it as our q. We just need to make sure, we don't overflow the queue as we are given a size.\n\n\n\nTime Complexity: <code>O(1)<\/code>, for each operation \nSpace Complexity: <code>O(n)<\/code>, n is..."},{"title":"Flatten\u00a0nested\u00a0list\u00a0iterator","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flatten-nested-list-iterator","snippet":"We will iterate over the nested list, and go through each element and add that to a queue. Then when we need to check the next, we can pop the value from the queue. For the hasNext, we can just check whether the queue is empty or not.\n\n\n\nTime Complexity:..."},{"title":"Push dominoes","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/push-dominoes","snippet":"Any triplet that reaches the state <code>R.L<\/code> remains that state permanently. These changes occur to pairs that are not part of an <code>R.L<\/code>, <code>R.<\/code> -> <code>RR<\/code> an <code>.L<\/code> -> <code>LL<\/code>. To avoid the problem with..."},{"title":"Reverse string II","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-string-ii","snippet":"We will divide the string to a list if characters. Then we take k characters and reverse it. Then we skip another k characters and take the next k characters. So, we are looping over the list with 2*k jump in each iteration. Then when the iteration is..."},{"title":"Strictly\u00a0palindromic\u00a0number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/strictly-palindromic-number","snippet":"We can convert the number to it's base, and check whether it's a palindromic string or not, and return the result.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity: <code>O(1)<\/code>\n\nThere is a better way to check, the number n in base (n - 2)..."},{"title":"Satisfiability\u00a0of\u00a0equality\u00a0equations","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/satisfiability-of-equality-equations","snippet":"We make an undirected graph in which the nodes are integers (as lower-case letters) and each edge connects integers that are equal. We use the union-find algorithm to determine the connected graphs. We keep track of the pairs (a,b) such that a =! b. If..."},{"title":"Count\u00a0nice\u00a0pairs\u00a0in\u00a0an\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-nice-pairs-in-an-array","snippet":"The problem statement says nums[i]+rev(nums[j]) == nums[j]+rev(nums[i]) is the defination of nice pairs. This can also be restated as nums[i]-rev(nums[i]) == nums[j]-rev(nums[j]). We will use this formula, and add the difference in a lookup table. And..."},{"title":"Concatenation\u00a0of\u00a0consecutive\u00a0binary\u00a0numbers","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/concatenation-of-consecutive-binary-numbers","snippet":"We will take a brute force approach to solve the problem. But rather than using <code>bin<\/code> function to convert the number to binary, which is prefixed with <code>0b<\/code>, we can use the format function to get rid of those prefixes. Then we can..."},{"title":"Partition\u00a0to\u00a0k\u00a0equal\u00a0sum\u00a0subsets","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-to-k-equal-sum-subsets","snippet":"We can try to split the numbers to k subsets, for that every subsets' sum will be total sum divided by k. It is best to iterate the input from biggest numbers, so that we can cut off bad solution close to the root of the decision tree. So, we sort the..."},{"title":"Reverse\u00a0words\u00a0in\u00a0a\u00a0string III","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-words-in-a-string-iii","snippet":"We will split the words, then reverse each word indivisually, then merge them together and return as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Sum\u00a0of\u00a0even\u00a0numbers\u00a0after\u00a0queries","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-even-numbers-after-queries","snippet":"We will first calculate the sum of all even values. Then we follow the problem instruction, calculate the even sum after modifying the value according the query, then update the even sum and append it to our result. Finally after iterating through all..."},{"title":"Find\u00a0duplicate\u00a0file\u00a0in\u00a0system","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-duplicate-file-in-system","snippet":"We will iterate over each path, extract the content, and based on the content, we will attach it to a hashmap where the key will be the content. Then we filter out the single files and return the rest as result.\n\n\n\nTime Complexity: <code>O(n)<\/code>..."},{"title":"Number\u00a0of\u00a0sub\u00a0arrays\u00a0with\u00a0odd\u00a0sum","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-sub-arrays-with-odd-sum","snippet":"We will start counting both the odd and even numbers in the array. If the current number is even, then the number of odd subarray will the count of odd numbers. Otherwise, we will change the odd by adding 1 to the even numbers, and swap even with the old..."},{"title":"Deepest\u00a0leaves\u00a0sum","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/deepest-leaves-sum","snippet":"We will run a BFS to get the sum of each level, then return the last level sum as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Iterator\u00a0for\u00a0combination","categories":["design","backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/iterator-for-combination","snippet":"We will generate all the combination using backtracking and store it in the class. Then for each next call, we will increase our index and return the value of previous index. For hasNext, we will just check whether our index already reached the end of..."},{"title":"Design\u00a0an\u00a0atm\u00a0machine","categories":["greedy","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-an-atm-machine","snippet":"We will store all the notes to an array, which will be the attribute of the class. We will also have a lookup notes dictionary. For deposit, we will just increase the number of bank notes in the ATM machine. When withdraw, we will take a greedy approach,..."},{"title":"Finding\u00a0pairs\u00a0with\u00a0a\u00a0certain\u00a0sum","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/finding-pairs-with-a-certain-sum","snippet":"We will create 2 counter for both nums1 and nums2 and also we will keep track of nums2. Every time we add something, we increase the value in nums2, and update the counter. The for count, we will iterate over every item in nums1 counter and match it with..."},{"title":"Maximum\u00a0score\u00a0from\u00a0performing\u00a0multiplication\u00a0operations","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-score-from-performing-multiplication-operations","snippet":"We will start from the beginning of the both array and calculate the left and right value recursively. Then we will compare them and return the highest result. We will then use memoization to reduce redundant calculation.\n\n\n\nTime Complexity:..."},{"title":"Minimum\u00a0genetic\u00a0mutation","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-genetic-mutation","snippet":"We first convert the genetic sequence bank list to set for constant time lookup. If the end is not in bank, we immediately return -1. Else we start from start sequence, check every possible genetic sequence, and start traversing the decision tree with..."},{"title":"Minimum\u00a0insertions\u00a0to\u00a0balance\u00a0a\u00a0parentheses\u00a0string","categories":["stack","greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-insertions-to-balance-a-parentheses-string","snippet":"We will iterate over each character, if the character is <code>(<\/code>, then we need 2 more, and if it is <code>)<\/code>, the we remove one from need. If the need is not even, then we add 1 in our result and remove it from the need. If need reached -1,..."},{"title":"Stone\u00a0game","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stone-game","snippet":"When the piles remaining are piles[i], piles[i+1], ..., piles[j], the player who's turn it is has at most 2 moves.\n\nThe person who's turn it is can be found by comparing j-i to N modulo 2.\n\nIf the player is Alice, then she either takes piles[i] or..."},{"title":"Find\u00a0original\u00a0array\u00a0from\u00a0doubled\u00a0array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-original-array-from-doubled-array","snippet":"We will first count the number of elements in the changed array. Then we will look for 0. If the count of 0 is odd, we return empty array, else we add half of them in our result. Then we sort the keys of the count hashmap, iterate over them, if we don't..."},{"title":"Validate\u00a0ip\u00a0address","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/validate-ip-address","snippet":"We will split the string with <code>.<\/code> and <code>:<\/code>. If the number of chunk is not 4 for ipv4 or not 8 for ipv6, we return Neither. Otherwise, we check check separately, for ipv4, each chunk must be within 0 and 255. For ipv6 each chunk must..."},{"title":"Insufficient\u00a0nodes\u00a0in\u00a0root\u00a0to\u00a0leaf\u00a0paths","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/insufficient-nodes-in-root-to-leaf-paths","snippet":"We will traverse the node with DFS and each time we reach a leaf node, we check for the insufficient node, if the node is insufficient, we delete it from the tree. After traversal of whole tree, we return the root node.\n\n\n\nTime Complexity:..."},{"title":"Pseudo\u00a0palindromic\u00a0paths\u00a0in\u00a0a\u00a0binary\u00a0tree","categories":["backtracking","tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pseudo-palindromic-paths-in-a-binary-tree","snippet":"We will start from root and traverse the root with DFS. In the process we will count the occureance of each node's value. Whenever we reach a root node, we will check for pseudo palindrome, if found one we increase the result count, else we remove that..."},{"title":"Spiral matrix\u00a0II","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/spiral-matrix-ii","snippet":"First we will initialize the matrix with 0 value in all of it's position. Then we will determine the value of left, right, top and bottom. Then we assing the value k from the top row to our matrix, then right column, then bottom row in reverse order and..."},{"title":"Is graph bipartite","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/is-graph-bipartite","snippet":"If we run BFS, then every level of traversal will have a different color. So we start from node 0, then start traversal using BFS and on each level, we alternate the color. In the process if we find 2 adjacent node has same color, that means the graph is..."},{"title":"Range\u00a0sum\u00a0query\u00a0immutable","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/range-sum-query-immutable","snippet":"We will store the nums as a class property and each time there is a query, we sum up the range in between and return the result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>\n\nWe can also use a prefix sum array to store the..."},{"title":"Reorder\u00a0data\u00a0in\u00a0log\u00a0files","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reorder-data-in-log-files","snippet":"We will create two different array, one for the letter logs and another for the digits logs. Then we iterate over all the logs and separate them. Then we sort the letters log, first by the content, and if the content are the same then by the key. Finally..."},{"title":"UTF-8\u00a0validation","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/utf-8-validation","snippet":"We will follow the problem statement and assume everything is correct and move forward. We will use a try-except statement if anything goes wrong and will return false from the except statement.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Bag\u00a0of tokens","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/bag-of-tokens","snippet":"We will first sort the tokens and take 2 pointers. If the value of the left pointer token is less than our power, we face down the token, so our score increase, we will also keep a running max score. If our score is already greater than 1, then we face..."},{"title":"Different\u00a0ways\u00a0to\u00a0add\u00a0parentheses","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/different-ways-to-add-parentheses","snippet":"We will create a decision tree with all possible options. As it is given only 3 types of operation is possible, we will check whether the current character belongs to any of these, then we calculate the left part and right part of the expression and..."},{"title":"Elimination game","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/elimination-game","snippet":"We will recursively eleminate people from beginning to end and then return backword with the same logic until only one person left, then return that.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Longest\u00a0word\u00a0in dictionary","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-word-in-dictionary","snippet":"We will create a trie and insert all the words in our trie. Then we run BFS to get the largest word, as we are only append the word in our BFS queue, when we reach word's end. So, the longest word will always come later, and if we have multiple word with..."},{"title":"Sender\u00a0with\u00a0largest\u00a0word count","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sender-with-largest-word-count","snippet":"We will create a count each words of the the messages for each sender. Then we take the sender with the highest number of word count, sort them and then return the largest sender name lexicographically.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace..."},{"title":"Find\u00a0the\u00a0city\u00a0with\u00a0the\u00a0smallest\u00a0number\u00a0of\u00a0neighbors\u00a0at\u00a0a\u00a0threshold\u00a0distance","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","snippet":"We will first create an adjacency list from the edge list. Then we run dijkstra's shortest path algorithm to get the number of neighbors of a city. We will run this dijkstra's algorithm for each node and store it to a distances list. We will get the..."},{"title":"Max\u00a0sum\u00a0of\u00a0a\u00a0pair\u00a0with\u00a0equal\u00a0sum\u00a0of digits","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-sum-of-a-pair-with-equal-sum-of-digits","snippet":"This problem is very similar to two sum problem. But instead of storing the complement of the number, we will store the sum of digits of the number. When we iterate over the numbers, we will also keep a running result for the max of the number pair. If..."},{"title":"Maximum difference\u00a0between node and ancestor","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-difference-between-node-and-ancestor","snippet":"We will keep track of both max value of the tree and min value of the tree from root to leaf. When we reach the leaf, we store the difference between these 2 in our result. We will run the same logic in both left and right subtree and finally return the..."},{"title":"Maximum performance of a team","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-performance-of-a-team","snippet":"We will take a queue to store the maximum k number of speed. Then we iterate over the sorted array which we will create by combining efficiency and speed array, push the item to the heap, also count the sum of the items in heap. Then we multiply the sum..."},{"title":"Minimum falling path sum","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-falling-path-sum","snippet":"We will create a helper function that will calculate the minimum path from the starting row and and column. In the helper function we will check the boundary of the column, if it is out of boundary then we return infinity. If we reach the last row, we..."},{"title":"Number\u00a0of\u00a0restricted\u00a0paths\u00a0from\u00a0first\u00a0to\u00a0last node","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-restricted-paths-from-first-to-last-node","snippet":"We will first create an adjacency list from the edge list. Then we run dijkstra's shortest path algorithm to get the shortest distance from first node every other node. Then we run DFS from first node to the last node, and each time we find a shortest..."},{"title":"Best\u00a0time\u00a0to buy and sell stock II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock-ii","snippet":"We will create a helper function to calculate the max profit, in each step, we can either buy or if we already bought, then we can sell. And each of these steps, we can either take the item or skip the item. Then we will take the maximum of these two and..."},{"title":"Best\u00a0time\u00a0to buy and sell stock III","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock-iii","snippet":"We will create a helper function to calculate the max profit, in each step, we can either buy or if we already bought, then we can sell. And each of these steps, we can either take the item or skip the item. We will also keep track of the number of..."},{"title":"Best\u00a0time\u00a0to buy and sell stock IV","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock-iv","snippet":"We will create a helper function to calculate the max profit, in each step, we can either buy or if we already bought, then we can sell. And each of these steps, we can either take the item or skip the item. Then we will take the maximum of these two and..."},{"title":"Coloring a border","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/coloring-a-border","snippet":"We will run a DFS starting from given row and column and get all the nodes that are same color. If a node is not in perimeter of the same color region, the number of adjacent node will be 4 for this node. We if we find a node that has less than 4 nodes..."},{"title":"Count and say","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-and-say","snippet":"As the title says, we just do what the question says. The base-case has already been provided. All we need to do now is to write the recursive calls. The answer to that is provided in the question as well. Get the answer to <code>countAndSay(n-1)<\/code>..."},{"title":"Island perimeter","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/island-perimeter","snippet":"We will run a DFS starting from given row and column and get all the nodes that are same color. If a node is not in perimeter of the same color region, the number of adjacent node will be 4 for this node, that means it will have no exposed perimeter to..."},{"title":"Maximum binary tree II","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-binary-tree-ii","snippet":"We will run a simple DFS to find the place and insert the new node there.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Maximum binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-binary-tree","snippet":"We will recursively create our tree, we will take the largest number of the array and put it as root. Then we will create the left subtree with the left elements from the input of the root, and right subtree with the right elements. Finally we will..."},{"title":"Partition array according to given pivot","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-array-according-to-given-pivot","snippet":"We will take 3 list, one for less, one for equal and one for more than the pivot value. Then we iterate over the input list, append the value to the respective list. Finally we combine 3 list, and return as result.\n\n\n\nTime Complexity: <code>O(n)<\/code>..."},{"title":"Wildcard matching","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/wildcard-matching","snippet":"We will start from the first character from the beginning of 2 sting, if they match, then we move to the next string, if the character is <code>?<\/code> in p, then also we move to the next string. If the character is <code>*<\/code>, then we move match..."},{"title":"Design a food rating system","categories":["heap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-a-food-rating-system","snippet":"We will have a hashmap for mapping the food to the cuisines and another hashmap to for the ratings. Whenever we receive a new rating or change rating, we add it to our max heap where we store the rate and food based on cousine. Then when we look for..."},{"title":"Minimum number of swaps to make the string balanced","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-swaps-to-make-the-string-balanced","snippet":"We will iterate over the string, for each opening bracket, we increase the left count by 1. For each closing bracket, if the count of left braket is greater than right bracket, then we increse the count of right bracket, else we increase the count of..."},{"title":"Peeking iterator","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/peeking-iterator","snippet":"We will use a current value property in the class to keep track of current value of the iterator. For rest of the functionality we will just relay the behaviour of the original iterator.\n\n\n\nTime Complexity: <code>O(1)<\/code> \nSpace Complexity:..."},{"title":"Remove linked list elements","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-linked-list-elements","snippet":"We will create a dummy node and attach it before our head. Then we will iterate over each node, if the value of the node is equal to our node, we will remove them. Then we will return the next node of our dummy node as result.\n\n\n\nTime Complexity:..."},{"title":"The number of weak characters in the game","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/the-number-of-weak-characters-in-the-game","snippet":"We will use a max heap with our properties and use the attack as sorting mechanism. Then we loop over our properties, pop the max item from the heap, and then we need to check the current defense, whether it is less than max defense or not. If yes, then..."},{"title":"Tuple with same product","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/tuple-with-same-product","snippet":"We will first count the product of 2 elements to a hashmap, where the key will be product. Then we iterate over each product, if it is more than 1, then we calculate the number of tuple by <code>(n*(n-1)\/2)*8<\/code>.\n\nEach product value represents 2..."},{"title":"Build an array with stack operations","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/build-an-array-with-stack-operations","snippet":"We will create a stack to match with our target and also create a result list. Then we start a loop from 1 to n and append each number to the stack. If the top of the stack does not match our target, we remove it and move to the next item. Along the way..."},{"title":"Combination sum III","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/combination-sum-iii","snippet":"We will run DFS towards our decision tree, for building a decision tree, we have 2 options, either we take the number or we skip the number. We will check when the sum of the numbers we took is equal to n and we took exactly k numbers starting from 1,..."},{"title":"Find k closest elements","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-k-closest-elements","snippet":"We will iterate over our input array, find the absolute diffrece of each elements form target x, and put them into a heap alogn with the actual number. Then we pop k numbers from the heap, sort the values and return them as result.\n\n\n\nTime Complexity:..."},{"title":"Maximum erasure value","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-erasure-value","snippet":"We will use a set to keep track of repeating numbers. We will have 2 pointers, we will move our right pointer, check if the number as right pointer is already exist in the set, if exists, then we remove number from left until the number is removed, also..."},{"title":"Minimum consecutive cards to pick up","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-consecutive-cards-to-pick-up","snippet":"We will use a set to keep track of cards in the hand. Initially we will assume the current number of cards in the hand in infinity. We will have 2 pointers, we will move our right pointer, check if the number as right pointer is already exist in the set,..."},{"title":"Repeated dna sequences","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/repeated-dna-sequences","snippet":"We will use a sliding window which is 10 characters long. For each window, we will add this to a lookup set. If the window is already present in the lookup set, that means we already have it more than once, we will add this to our result set, we are..."},{"title":"Robot bounded in circle","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/robot-bounded-in-circle","snippet":"The idea is, after the first iteration, if the direction is not north facing or the current position is the start position, then it is a cycle, otherwise not.\n\nFirst if condition basically encounters the instructions value and changes the co-ordinates..."},{"title":"Construct string from binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/construct-string-from-binary-tree","snippet":"We will use recursive DFS to traverse the tree and append the result to a string and return it.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Keys and rooms","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/keys-and-rooms","snippet":"We will create a set with all the nodes. First we put them in unvisited set. Then we start traversing the graph using BFS and remove nodes from unvisited set after every node visit. Finally when the traversing is done, if the unvisited set is empty that..."},{"title":"Print binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/print-binary-tree","snippet":"First we will calculate the height of the tree. Our result will be a 2d matrix where the each row will have <code>2^height-1<\/code> element and there will be <code>height<\/code> rows in total. We initialize our result with empty string.\n\nThen we..."},{"title":"Binary tree pruning","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-pruning","snippet":"We will do a recursive DFS and check there the leaf node is 0 if 1, if it's 0, we remove it. Finally return the tree root.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Design a stack with increment operation","categories":["design","stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-a-stack-with-increment-operation","snippet":"We will create a stack and store the max length of the stack. If someone push anything, if the stack is not already full, we will push it to the stack. Similarly, is the stack is not empty, we returned the popped element else return -1. For increment, we..."},{"title":"H-index II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/h-index-ii","snippet":"We will seach for the highest mid where the value of mid is greater that or equal to the numbers of elements on the right from that mid index.\n\n\n\nTime Complexity: <code>O(log(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"H-index","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/h-index","snippet":"We will use count sort to sort the elements in linear time and then search for the highest value, where numbers of elements after that index is greater than or equal to that value.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Implement magic dictionary","categories":["trie","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/implement-magic-dictionary","snippet":"We will use the Trie data structure to store all the elements in the dictionary. Building the dictionary is pretty strait forward, we will insert all the words from the dictionary to the trie.\n\nAs we cannot assume the input do not contain one-character..."},{"title":"Lexicographical numbers","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lexicographical-numbers","snippet":"We can just create a list of numbers from 1 to n, convert them to string and sort them.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>\n\nAlso, we can create a decision tree from the numbers where we will take 1 element,..."},{"title":"Linked list random node","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/linked-list-random-node","snippet":"When we initialize the solution class, we will traverse the whole list and store it's values to a list. Then each time we are asked to get a random number, we will use random module to choose a value from the list and return.\n\n\n\nTime Complexity:..."},{"title":"Merge\u00a0nodes in between zeros","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-nodes-in-between-zeros","snippet":"We will create a dummy node for our result. Then we will start from the head, sum the values of the nodes until we reach another 0, then attach a node to our result list. We will repeat it until we reach the end of the list.\n\n\n\nTime Complexity:..."},{"title":"Query kth smallest trimmed number","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/query-kth-smallest-trimmed-number","snippet":"We will take the nums, iterate over each query, and take the last trim values of the nums and store it as integer in a values array along with the index. Then we sort this values array and take the kth value and append it to our result. After the..."},{"title":"Remove stones to minimize the total","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-stones-to-minimize-the-total","snippet":"We will use a max heap to get the top k elements from the piles. As python does not have max heap out of the box, we can multiply each element by -1 and thus min heap will work as max heap. Now we take the top element, divide it half, and then push it..."},{"title":"Replace words","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/replace-words","snippet":"We will use a prefix tree or trie with our dictionary. Then for each word in the sentence, we will look for the root of the word in the trie, if we found something, we will replace it with our root, else we will skip it and move to the next word. We will..."},{"title":"Reverse words in a string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-words-in-a-string","snippet":"We will strip the extra space and then split the string with space. Finally, we reverse the words, combine them to a string and return.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Seat reservation manager","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/seat-reservation-manager","snippet":"We will create a min heap with the capacity of the seat manager. Then when someone reserve a seat, we will pop it from our min heap, and when someone unreserve a seat, we will push back the value to our heap.\n\n\n\nTime Complexity: <code>O(n)<\/code> for..."},{"title":"Smallest number in infinite set","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/smallest-number-in-infinite-set","snippet":"We will first create a heap with 1000 elements from 1 to 1000 as at most 1000 call will be made. If we want to add something, we will check whether it is already present in the heap, if not, we will push it to the heap. When we want to pop the smallest,..."},{"title":"Sort an array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-an-array","snippet":"We will use divide and conquar to solve this sorting porblem. We will be using classic merge sort.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(nlog(n))<\/code>"},{"title":"Sort characters by frequency","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-characters-by-frequency","snippet":"We will first count the characters of the string and sort them by frequency. Then iterate over it, put the character as many time as it appear in the original string, then finally merge it together to get the result.\n\n\n\nTime Complexity:..."},{"title":"All\u00a0ancestors\u00a0of\u00a0a\u00a0node\u00a0in\u00a0a directed acyclic graph","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/all-ancestors-of-a-node-in-a-directed-acyclic-graph","snippet":"First we will create an ancestors adgacency list, where we can get the immediate parent of each node from the edge list. Then we will run DFS from each node, and get the node list of all reachable nodes as a list and append that to our result. Finally we..."},{"title":"Basic calculator II","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/basic-calculator-ii","snippet":"We will take a stack. Initially our operation and operand will be 0 and <code>+<\/code> append each character to the stack. If the character is numeric, until we reach an operand we will calculate the value. When we reach an operand, we will calculate the..."},{"title":"Basic calculator III","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/basic-calculator-iii","snippet":"We will take a stack. Initially our operation and operand will be 0 and <code>+<\/code> append each character to the stack. If the character is numeric, until we reach an operand we will calculate the value. When we reach an operand, we will calculate the..."},{"title":"Basic calculator","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/basic-calculator","snippet":"We will take a stack. Initially our operation and operand will be 0 and <code>+<\/code> append each character to the stack. If the character is numeric, until we reach an operand we will calculate the value. When we reach an operand, we will calculate the..."},{"title":"Battleships in a board","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/battleships-in-a-board","snippet":"We will run DFS to explore all the values after we found one <code>X<\/code> and mark that as visited and count the number of battleship by 1. After traverse the whole board, we will return the count as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Count primes","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-primes","snippet":"We will use the algorithm Sieve of Eratosthenes to find the number of primes within a range.\n\n\n\nTime Complexity: <code>O(nlog(log(n)))<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Course schedule IV","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/course-schedule-iv","snippet":"We will first create an adjacency list from the prerequisites. Then for each queires, we will start DFS from course 1 to course 2, if we can reach to course 2, then we append true in our result, else we append false. Finally, we will return our result..."},{"title":"House robber III","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/house-robber-iii","snippet":"We will traverse the tree in DFS and take both with and without root result. Then we calculate the max from both of them and return the result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Linked list cycle II","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/linked-list-cycle-ii","snippet":"We can use Floyd's cycle detection algorithm to find the position. We will create a fast and slow pointer, fast pointer is twice as fast as the slow pointer. If the two pointer doesn't meet, that means there is no cycle, then we return a null node. If..."},{"title":"Longest absolute file path","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-absolute-file-path","snippet":"Use stack to represent structure of a directory where the root of a directory is at index 0. Directory level can be infer from the number of tabs. ie \"\" is level 0, \"\\n\" is level 1 and so on.\n\nStart by splitting input based on nextline. For each path,..."},{"title":"Number of enclaves","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-enclaves","snippet":"We will run DFS from every bordering position of the grid and turn the 1's to 0's. Then we will just count the number of position where we still have 1's left, and return that count as result.\n\n\n\nTime Complexity: <code>O((m*n)^2)<\/code> \nSpace..."},{"title":"Path sum II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-sum-ii","snippet":"We will use DFS along with backtracking to get the paths of every root to leaf path that adds upto the target.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>, for recursive call stack"},{"title":"Remove duplicate letters","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicate-letters","snippet":"We will create a hashmap to keep track of last occurance of the letters. Then we will have a visited hashset and a stack to keep track of the letters. We traverse sequentially on the string, for each character we check whether it's already in stack or..."},{"title":"Restore ip addresses","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/restore-ip-addresses","snippet":"We will create a decision tree based on the rule that each segment of the ip address can be between 0 and 255. Then we run our DFS to get all possible options and return the result.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity:..."},{"title":"Search in rotated sorted array II","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-in-rotated-sorted-array-ii","snippet":"To solve this problem we have to follow the folllowing steps:\n\n\nCalculate the mid index.\nCheck if the mid element == target, return True else move to next step.\nElse if the mid element >= left. If mid element >= target and and left &lt;= target, then..."},{"title":"Single number II","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/single-number-ii","snippet":"We will have 2 elements, one will be store all the values that store all the elements that occurs once and two will store all the elements that occurs twice. Then we make sure that the values that is in one does not belongs in two. So, for getting one,..."},{"title":"Single number III","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/single-number-iii","snippet":"We will be using the XOR trick i.e <code>n^n=0<\/code>. During first traversal we will get the XOR of the required two numbers, then we will get the least significant bit of the XOR operation. This means the two numbers should have opposite bits at the..."},{"title":"Sort list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-list","snippet":"We will use standard merge sort to sort the list, to get the middle node, we will use a fast and slow pointer approach, rest is standard merge sort stuffs.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(nlog(n))<\/code>"},{"title":"Amount of time for binary tree to be infected","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/amount-of-time-for-binary-tree-to-be-infected","snippet":"We will first create an adjacency list for our tree. Then we run a simple BFS to traverse all the nodes, and the number of level we need to traverse is our time.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Binary search tree iterator","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-search-tree-iterator","snippet":"We will create a queue to store our values while create the oterator class. Then for next, we will pop the values from the queue and return, for hasNext, we will check it the queue is empty or not.\n\n\n\nTime Complexity: <code>O(n)<\/code> for the init,..."},{"title":"Binary tree level order traversal II","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-level-order-traversal-ii","snippet":"This is a classing BFS problem. We should traverse the whole tree with BFS, and store the values level by level to a list. Then combine each level to a list and return the reversed list as result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Binary tree zigzag level order traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-zigzag-level-order-traversal","snippet":"We will traverse the tree with BFS and append the values of each level to our result list. And for each alternative level we change the order. Finally return the result after we visit each node.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Construct binary tree from inorder\u00a0and postorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/construct-binary-tree-from-inorder-and-postorder-traversal","snippet":"We know, the last index of postorder traversal is always the root of the tree, from that info, we can find the root in inorder traversal too. From there, we will find the left inorder subtree and right inorder subtree and with the length of left and..."},{"title":"Convert sorted list to binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-sorted-list-to-binary-search-tree","snippet":"We will first loop over the entire linked list and add the values to a list. Now we will take the middle index of the list as our root and recursively build both the left and right subtree and return the tree as result.\n\n\n\nTime Complexity:..."},{"title":"Count complete tree nodes","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-complete-tree-nodes","snippet":"We will count the height of the left and right subtree. If they are equal, then the it's a complete tree, so the number of node will be <code>2^n-1<\/code>. If it's not a complete tree, then the number of node will be 1 + number of nodes in the left..."},{"title":"delete-node-in-a-bst","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/delete-node-in-a-bst","snippet":"We will check whether the key is greater than root, then the key is in right subtree, if the key is less than root, then key is in left subtree. If the key is the root, then we check, if there is a no left or right subtree, then we return null. If there..."},{"title":"Evaluate division","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/evaluate-division","snippet":"We will first create an adjacency list from the provided equations and values list. Each node will have the related node and thier weight in it. Then we run DFS to find the result. Finally, we will run every query through our dfs and append the output to..."},{"title":"Populating next right pointers in each node II","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/populating-next-right-pointers-in-each-node-ii","snippet":"We will traverse the tree with BFS and in each level, we will append the nodes to a list. After each level traversal, we take these nodes, and assing the next node to it's right node. We will repeat the process in each level and finally return our root...."},{"title":"Populating next right pointers in each node","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/populating-next-right-pointers-in-each-node","snippet":"We will traverse the tree with BFS and in each level, we will append the nodes to a list. After each level traversal, we take these nodes, and assing the next node to it's right node. We will repeat the process in each level and finally return our root...."},{"title":"Recover\u00a0binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/recover-binary-search-tree","snippet":"We will traverse the tree with inorder traversal and add each nodes to the a list. Then we sort the values of each nodes, then iterate over the sorted values, and assign the values to respective tree nodes values.\n\n\n\nTime Complexity:..."},{"title":"Unique binary search trees II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-binary-search-trees-ii","snippet":"We will take the top-down approach to solve the problem. We will start from 1 and for every position, we take is as root, and build a tree with the left and right subarray for that root position, then create a tree with the values and add that tree to..."},{"title":"Unique binary search trees","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-binary-search-trees","snippet":"We will take the top-down approach to solve the problem. We will start from 1 and for every position, we take is as root, and build a tree with the left and right subarray for that root position, and add that to our result. Finally we will memoize it so..."},{"title":"Verify preorder serialization of a binary tree","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/verify-preorder-serialization-of-a-binary-tree","snippet":"We will split the string with <code>,<\/code> as delimeter, and pop the last value from it to check whether it's a <code>#<\/code> or not, if not, we immediately return false. Then we iterate over the values, if the character is not <code>#<\/code> we..."},{"title":"Vertical order traversal of a binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/vertical-order-traversal-of-a-binary-tree","snippet":"We will first traverse the tree with DFS and store it's values along with row and column in the the process. Then we sort them by column value and group them by column value. Finally, take all these groups, combine it to a list and return the values...."},{"title":"Balance a binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/balance-a-binary-search-tree","snippet":"We will first traverse the tree with inorder traversal, and append all the values to an array. Then we create a binary search tree with the values, where root will be the middle of the array, thus we make sure there are roughly same number of nodes in..."},{"title":"Decode string","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/decode-string","snippet":"We will use a stack and append the values until we reach <code>]<\/code>. Then we pop the values from stack and make a string until we reach <code>[<\/code>. Then we pop the numbers from the stack and multiply it with the string and push it back to the..."},{"title":"Design underground system","categories":["design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-underground-system","snippet":"We will use 2 hashmap to store the passengers data and travel time data. When someone check if, we add it to the passengers hashset, along with the time. When someone check out, we take the start time from the hashset, and add the difference in out..."},{"title":"Equal row and column pairs","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/equal-row-and-column-pairs","snippet":"We will create a hashmap where we will count the rows occurance, the key will be the row as tuple and the value will be the count. Then we move through the column, search in the lookup hashmap for any match, if we found one, count this as out result...."},{"title":"Gray code","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/gray-code","snippet":"There is formula to get Gray's code, for every number i, it <code>i ^ (i&gt;&gt;1)<\/code>. We can use the foumula to get the values for 2^n numbers and return it as the result.\n\n\n\nTime Complexity: <code>O(2^n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Largest number","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-number","snippet":"We will take the input array, and sort it with our custom compare method, where we sort it in natural string order in reverse. Then we convert the the numbers into string and merge it together to get our result. But first we will check whether the..."},{"title":"Minimum moves to equal array elements II","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-moves-to-equal-array-elements-ii","snippet":"We will first take the median of the array by sorting it and take the middle value, this will be our target. Then we take the difference from each number to the target, add that up and return that as our result.\n\n\n\nTime Complexity:..."},{"title":"Numbers with same consecutive differences","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/numbers-with-same-consecutive-differences","snippet":"We will start from 1, and then take the last digit of the number, add k to it and append to the right of the current number, until we reach the required length of n. We append every number on the way to our result and finally return it.\n\n\n\nTime..."},{"title":"Sell diminishing valued colored balls","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sell-diminishing-valued-colored-balls","snippet":"One naive approach is to repeat for orders times, and each time, take the largest one, decrease it and place back to the array. This will take O(orders * logN) time complexity if using heap.\nLet's sort the array first, from max to min.\n\nOne important..."},{"title":"Average of levels in binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/average-of-levels-in-binary-tree","snippet":"We will run BFS and after traversal of each level, we append the average in our result, and finally return it after the end of traversal.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Minimum time difference","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-time-difference","snippet":"First we convert the hours into minutes and append them into a new array. Then we sort the new array and go through each element and look for minimum difference. Once we reach the last element in the list, we compare the last element with the first..."},{"title":"Reachable nodes with restrictions","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reachable-nodes-with-restrictions","snippet":"We will create an adjacency list from the edges list. Then we convert our restricted list to a set for constant lookup. Then we perform a BFS to visit all the nodes, if the node is already been visited or in the restricted set, we return from that node...."},{"title":"Sudoku solver","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sudoku-solver","snippet":"We will use 3 hashset to store the value of rows, columns and boxes. For rows and columns hashset we will use the row and column number as key. For square hashset, we can use the integer division of the row, column value by 3, and use the set as key. For..."},{"title":"Sum root to leaf numbers","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-root-to-leaf-numbers","snippet":"We will run DFS from root to leaf, along in the way, we calculate the number for root to leaf value. Once we reach the leaf, we add it to our result. Finally we return the result after traversal is over.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"4sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/4sum","snippet":"We will sort the array and start from first element i, the take the next element j which is not equal to i, then take the next element as l, and the last element of the list as r, added them, compare them with the target, if we found a match, we add it..."},{"title":"Bitwise and of numbers range","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/bitwise-and-of-numbers-range","snippet":"If the right crosses the next 2^n of left where n is the number of bits for left, that means 2^n >= left, then the result is always going to be 0. For example, AND product of <code>1010<\/code> and <code>10000<\/code> will always be 0. We check that and..."},{"title":"Clumsy factorial","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/clumsy-factorial","snippet":"If we calculate some values, then we will notice some pattern. Here are some calculations-\n\n\n\nFrom this we can create the following method to calculate the clumsy factorial.\n\n\n\nTime Complexity: <code>O(1)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Insertion sort list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/insertion-sort-list","snippet":"We will create a dummy node and attach it at the beginning to make our life easier. Then we take 2 pointer, previous and current, previous will be our head and current will be the next node of previous. Then we move our current pointer to check if it is..."},{"title":"Integer to roman","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/integer-to-roman","snippet":"We will create 2 loopup table, one for ONES and another for FIVES. Then we start from least significant bit, check the value is 4 if we mod it by five, then take the value from FIVES lookup table, else take it from the ONES lookup table. If the the..."},{"title":"Minimum height trees","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-height-trees","snippet":"We will first create an adjacency list from the edge list. Then we start BFS from the leaf nodes, and whenever we visit a node, we add this to a list for current leaves, and decreasing the node count by 1 unlit we have only 2 nodes left. Each level of..."},{"title":"Minimum moves to equal array elements","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-moves-to-equal-array-elements","snippet":"Elevating n-1 elements is essensially same as decreasing 1 element. Thus we must decrease everything to the minimum value to get the result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"N-ary tree level order traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-ary-tree-level-order-traversal","snippet":"We will run BFS in each level and append the values in a result list, and return the list when traversal is done.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Next permutation","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/next-permutation","snippet":"We will take a pointer at the end of the list and move towards front until we a bigger value than the previous. If we reach all the way till the beginning, the the list is already in decreasing order, we can just return the reversed list. Then we take..."},{"title":"Simple bank system","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/simple-bank-system","snippet":"We will create a list in the class to track the balance of each account. Then on each operation we will check whether the account number is out or range or money is overflown to that account, if yes return false. Else we will perform the operation and..."},{"title":"Zigzag conversion","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/zigzag-conversion","snippet":"We will create an array with empty string for each row. Then we also have a direction value, which will be down at the beginning. Then we start from position 0, add items in each row until we reach the last row, then change our direction to up, and add..."},{"title":"Continuous subarray sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/continuous-subarray-sum","snippet":"We will take a hashmap and keep the reminder along with their index in it. As a base case, we will take the subarray sum as 0 and keep the index -1 as we don't added anything yet in the subarray sum. Then we iterate over each element, add this to our..."},{"title":"Rearrange words in a sentence","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rearrange-words-in-a-sentence","snippet":"We will split the word with space as delimeter, sort them according to their length, join then again with space, finally return the capitalize string.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Subarray sum equals k","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/subarray-sum-equals-k","snippet":"This problem can't be solved using sliding window as it is not only positive, or only negative or sorted. So, we iterate over each item in the input, calculate prefix sum and store it in a hashmap. Then we check whether the complement of the previous sum..."},{"title":"Furthest building you can reach","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/furthest-building-you-can-reach","snippet":"We will take the ladders for the longest obstackles. First we take the obstackles in a heap, then take the smallest, if the diff is less than or equals to the bricks, we take the bricks, else we take the ladder. That means, we are already in the place..."},{"title":"Get equal substrings within budget","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/get-equal-substrings-within-budget","snippet":"We will take 2 pointer, we will forward our right pointer, added the difference of s and t in a running sum and until it is less than max cost, we forward the right pointer. Then we forward the left pointer, and keep the difference of left and right..."},{"title":"Maximum xor of two numbers in an array","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-xor-of-two-numbers-in-an-array","snippet":"we will create a mask of first character 1 for all 32 position in a 32 bit integer. Then we created hashset to calculate which number has the largest most significant bit. Then we create a temporary variable to store the output, and check in the hashset..."},{"title":"Minimum moves to make array complementary","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-moves-to-make-array-complementary","snippet":"First we create an overlay lookup hashmap of size 2limit+2, as our minimum boundary of change is 2 and maximum is 2limit. Then we iterate over the elements in pair, take the first and last element, and calculate the overlay value for the left and right..."},{"title":"Remove duplicates from sorted list II","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicates-from-sorted-list-ii","snippet":"We will have 2 pointers, when we iterate over each node, we check if we found duplicate, then we move right pointer until we hit another value. Then remove all nodes between 2 pointers and move both pointers.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Remove duplicates from sorted list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicates-from-sorted-list","snippet":"We will check the current value to the next node value, if they are equal, we remove the current one, and move on till the end of the list.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"All paths\u00a0from source to target","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/all-paths-from-source-to-target","snippet":"We will always start from 0, so we add 0 in that path. Then we run DFS from 0, and when we find the last node, which is the length of the graph-1 node, we add this current path to our final paths list. Finally, when the iteration is done, we return our..."},{"title":"Divide two integers","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/divide-two-integers","snippet":"We will divide the dividend by the divisor and cast it to an integer. If the answer is bigger than 2^31-1, which is the highest value of 32-bit integer, we cap it to the highest 32-bit integer value, and return the result.\n\n\n\nTime Complexity:..."},{"title":"Minimum size subarray sum","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-size-subarray-sum","snippet":"We will take a sliding window, add it to the sum, if the sum is greater than or equals to the target, we calculate the width of our sliding window and compare with our current result and took the minimum. Then we move our left pointer to 1 place and..."},{"title":"Number of islands","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-islands","snippet":"We will iterate over the grid, if we found land which is 1, we start dfs from there, and added all the adjacent 1 to the visited set. We will also increase the number of islands for that. When the iteration of the whole grid is done, we will return the..."},{"title":"Number of provinces","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-provinces","snippet":"We will iterate over each item in the rows, reach row actually denotes the number of connections one city could have. So, we will run DFS in a given neighbors, and if it is not in the visited set, we count it as new province, and start DFS from that..."},{"title":"Remove duplicates from sorted array II","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicates-from-sorted-array-ii","snippet":"We will iterate over the whole array from index 1 to the end-1, compare the values of 3 consecutive values, if they are same, we change the first element to 10001, as our input can be as big as 10^4. Then we sort them and count the number of element..."},{"title":"Remove duplicates from sorted array","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-duplicates-from-sorted-array","snippet":"We will iterate over each element from index 1 to the end of the list, if 2 consecutive numbers are equals, we convert the first number to 101, as out input list could have numbers upto 100. Then we sort them, and count the number of elements which are..."},{"title":"Simplify path","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/simplify-path","snippet":"First we will split the the path with <code>\/<\/code> as delimeter. Then we iterate over the items of the path, if the item is <code>.<\/code> or empty, we just ignore it. If the item is anything but <code>..<\/code>, then we append it to a stack, else we..."},{"title":"Combinations","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/combinations","snippet":"This is classic backtracking problem.\n\nFor a given combination of values, you want only 1 tuple. You can achieve this by making sure that for 3 values a, b, c, that a &lt; b &lt; c. I implement this by limiting my search for potential future numbers to..."},{"title":"First missing positive","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/first-missing-positive","snippet":"We will use our input array as the hashset, so that we can solve the problem in constant space. First, we will iterate over the input, and mark each negative number to 0, as it doesn't have any significance in our result. Then we iterate over the input..."},{"title":"Game of life","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/game-of-life","snippet":"We will create a copy of the given matrix, also create a helper function to count the live neighbors. Then, we iterate over each element of the board, count it's live neighbors, then change the value of the board according to the rule of the game...."},{"title":"Sort the matrix diagonally","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sort-the-matrix-diagonally","snippet":"We will create a lehper function, that will take all the diagonal element from the matrix, based on a given row, column position, sort that and then replace the original matrix values with the sorted values. We will repeat that for each diagonal..."},{"title":"Unique paths II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-paths-ii","snippet":"We will first solve it with brute force using recursion and then use memoization to make it efficient. For recursion, we can think about the base case, if our current position is out of bound or it hits an obstacle, then we return 0, if we are at the end..."},{"title":"Validate stack sequences","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/validate-stack-sequences","snippet":"We will pushed each element from the pushed to a stack, and check if the top of the element is equal to the first element of popped, if yes, we pop the element from the stack. After we are done with the iteration, if the stack is empty, we return true,..."},{"title":"3sum closest","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/3sum-closest","snippet":"We have already sorted the 3 sum problem, it is basically the same problem with a little twist. First we sort the array, then we take the first element at first position, then for the rest of the elements we take 2 pointers, and then solve it like 2 sum,..."},{"title":"Check if a string contains all binary codes of size k","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-a-string-contains-all-binary-codes-of-size-k","snippet":"First we will divide the string to all possible substring of length k. Then add all of them into a hashset. If the length of the hashset is equals to 2^k, then we found all possible number and return true, else return false.\n\n\n\nTime Complexity:..."},{"title":"Interval list intersections","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/interval-list-intersections","snippet":"We will iterate over both list and check whether we have any overlaps or not, if we have we take the maximum of start time and minimum of end time as the intersection value and append it to our result list. After the iteration is done, we will return the..."},{"title":"Number of smooth descent periods of a stock","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-smooth-descent-periods-of-a-stock","snippet":"We will start by result and count to be equals to 1. Then in each iteration of the array from index 1 to the rest, we check with the previous element, if the previous number is exactly bigger by 1, then we add it to our count, and add the count to our..."},{"title":"Remove k digits","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-k-digits","snippet":"We will use a monotonic decreasing stack to keep track of the digits. We will remove most significant k digits from the stack and then return the values, if the stack is empty at that point we will return 0. While pushing any values in the stack we will..."},{"title":"Swap nodes in pairs","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/swap-nodes-in-pairs","snippet":"We will create a dummy node, and set this as previous node, assing next pointer to head. Then from head, we take 2 nodes each time, swap their positions, then move the current and previous node until the end of the list. Then return the next pointer of..."},{"title":"Minimum number of flips to make the binary string alternating","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-flips-to-make-the-binary-string-alternating","snippet":"We will take the string, and start comparing with first character as 0, and count the number of flips required. If we take first character as 1, the number of flips will be length of the string minus the flips of first character 0. If the input string is..."},{"title":"Reordered power of 2","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reordered-power-of-2","snippet":"We will count the number of digits in out given input. Then we take all the power of 2 from 1 to 32 bit integers, compare the digits of them, if any one of it matches with our given input, we return true, otherwise false.\n\n\n\nTime Complexity:..."},{"title":"Compare version numbers","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/compare-version-numbers","snippet":"First we split 2 versions with <code>.<\/code> and loop over the minimum number of both lenght, check whether one or two is bigger then return immediately. If both are equal, then we check whether we have any number left at any version, if yes, we return..."},{"title":"Count servers that communicate","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-servers-that-communicate","snippet":"We iterate over each row, and check if we have another 1 in the row, then we add both of them in the result count. We do the same thing for column, and iterate over it to find another value for 1 and add that. Finally, we return the count.\n\n\n\nTime..."},{"title":"Ransom note","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/ransom-note","snippet":"We will count each character from magazine, then we iterate over each character of ransom note, check whether it is available in the count, if not immediately return false. If present in the count, we decrease the value by 1. If we can iterate over the..."},{"title":"Power of three","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/power-of-three","snippet":"We will devide the number by 3 until it's 1. If in any step, we have any reminder, we will return false, otherwise return true.\n\n\n\nTime Complexity: <code>O(log(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Rotate list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rotate-list","snippet":"We will first iterate over the list to count the number of the nodes. Then took k and mod it with the count for mitigate overflow. Then we took 2 pointer, first one we iterate k times and then start both pointers until first pointer reaches the end. Then..."},{"title":"Palindrome linked list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/palindrome-linked-list","snippet":"We will iterate over the whole list, and add the result to an array. Then we check whether the array is palindrome or not and return that value.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Check if a word occurs as a prefix of any word in a sentence","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence","snippet":"We will split the string with space then iterate over each word to check the prefix, if we find one, we return the position of the word in the sentence, else we return -1.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Minimum deletions to make string balanced","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-deletions-to-make-string-balanced","snippet":"We can count the number of occurance of <code>b<\/code> and then reduce the count with an upcoming <code>a<\/code> character, also increase the result count on the way. Finally return our result count after the iteration is done.\n\n\n\nTime Complexity:..."},{"title":"Power of four","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/power-of-four","snippet":"We will devide the number by 4 until it's 1. If in any step, we have any reminder, we will return false, otherwise return true.\n\n\n\nTime Complexity: <code>O(log(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Check if the sentence is pangram","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/check-if-the-sentence-is-pangram","snippet":"We will count each character and add it to a hashmap. If the number of characters are equal to 26, we return true otherwise return false.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Construct binary tree from preorder and postorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/construct-binary-tree-from-preorder-and-postorder-traversal","snippet":"We know, the first value of preorder traversal is always the root. From than we can determine the the left subtree's preorder and postorder traversal, and right subtree's preorder and postorder traversal. From that we can recursively call out build tree..."},{"title":"Cousins in binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/cousins-in-binary-tree","snippet":"We will run a BFS in the tree, and will keep track of the parents, if we find a parent, in a level for one node, we will return false, if we find two parent in a row, we return true. If we find the whole tree without finding any parent, we then return..."},{"title":"Number of good ways to split a string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-good-ways-to-split-a-string","snippet":"We will first count the characters in the string. Then we iterate over the string, add this to the set, and remove the occurance from the count. Then if the length of the set is equal to the length of the count, we increase the result by 1. Finally..."},{"title":"Stamping the sequence","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stamping-the-sequence","snippet":"We will start from the target, then move backwords towards our source, which is a string of <code>?<\/code>. We will take a sliding window of length M, which is the length of the stamp, check whether it's matched with the stamp, if matched, we replace it..."},{"title":"Minimum number of refueling stops","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-number-of-refueling-stops","snippet":"We can be greedy and use a max heap to to count the number of refueling stop. First we will append the target to the stations list, where fuel will be 0. We will assing the startFuel as nextStop as it can take us up to the next stop. Then we iterate over..."},{"title":"Number of pairs of strings with concatenation equal to target","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-pairs-of-strings-with-concatenation-equal-to-target","snippet":"First we will count the number of frequency of each elements of the input. Then iterate over all possible slices of target and multiply by the count and add it to our final result. If some slices are missing in frequency array, it will return 0, so that..."},{"title":"The k weakest rows\u00a0in a matrix","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/the-k-weakest-rows-in-a-matrix","snippet":"First we iterate through the whole matrix to count the number of 1's in the matrix and put it in an min heap. Then we extract top k elements from that heap.\n\n\n\nTime Complexity: <code>O(n*m*log(k))<\/code>, n is the number of rows, m is the number of..."},{"title":"Design parking system","categories":["array-and-hashmap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-parking-system","snippet":"We will create a hashmap, with the capacity. Each time, we add a car, we decrease the capacity by 1. If the capacity is already filled up, we return false, otherwise return true.\n\n\n\nTime Complexity: <code>O(1)<\/code>, for each operation. \nSpace..."},{"title":"Split array into consecutive subsequences","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/split-array-into-consecutive-subsequences","snippet":"First we will count all the numbers. Then we will create a second hashmap to keep track of subsequences. Then we iterate over the input array, then if there is already a subsequence in place, we add the number to that, or we create a new subsequence. If..."},{"title":"Reduce array size to the half","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reduce-array-size-to-the-half","snippet":"We will count the values, then sort them. Then we start removing item from the most common elements and count them. When the removed elements reach more than half of the input array, we return the count of the removed elements.\n\n\n\nTime Complexity:..."},{"title":"Strange printer","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/strange-printer","snippet":"If we start from the last character, then it will always print with 1 switch. This will be our base case. We will run DFS to the rest of the characters. Then we will look through each elements until last character, then check whether we have the last..."},{"title":"Beautiful arrangement","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/beautiful-arrangement","snippet":"Generate the array of numbers that will be used to create permutations of 1 to n (n inclusive) ex: 3 will become [1, 2, 3]. Then, iterate through all elements in the list and compare it to i which is initialized at 1 to avoid the while index + 1 thing...."},{"title":"Unique morse code words","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-morse-code-words","snippet":"We will translate each word to a morse code and then add that to a set. Finally return the number of elements of that set.\n\n\n\nTime Complexity: <code>O(n*m)<\/code>, n is the number of words, m is length of largest word. \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Find triangular sum of an array","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-triangular-sum-of-an-array","snippet":"This problem is basically reverse pascal's triangle. For the ith element of one level, we can calculate it from the i and i+1 th element from the previous level and mod the result by 10. After each level, we will remove the last element of that level. We..."},{"title":"First unique character in a string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/first-unique-character-in-a-string","snippet":"First we will count each character of the string. Then we iterate from the beginning, check which character has character count 1, return that. If we can't find anything with character count 1, we return -1.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"N-th tribonacci number","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-th-tribonacci-number","snippet":"This problem is just like fibonacci number, we will first solve it recursively and then memoize it to reduce redundant calculation.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"String to integer atoi","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/string-to-integer-atoi","snippet":"First we will strip any whitespace characters, and then check if the length is zero, we immediately return 0. Then we check the sign, if the sign is <code>+<\/code> or <code>-<\/code>, we keep that in a sign variable and delete that from the numbers. Then..."},{"title":"Prime number of set bits in binary representation","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/prime-number-of-set-bits-in-binary-representation","snippet":"This is a very strait forward problem. We will have 2 helper function, one is for counting the number of bits in an integer and another for checking if the number is prime or not. Then we iterate over our limit, count every numbers' bit, then check if it..."},{"title":"Roman to integer","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/roman-to-integer","snippet":"We can replace characters like <code>IV<\/code> or <code>IX<\/code> to <code>IIII<\/code> and <code>VIIII<\/code>. In that way, when we calculate our result, we can just translate the value to integer withour any prior calculations. We will have a hashmap to..."},{"title":"Next greater element I","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/next-greater-element-i","snippet":"We traverse nums2 and start storing elements on the top of stack. If current number is greater than the top of the stack, then we found a pair. Keep popping from stack till the top of stack is smaller than current number. After matching pairs are found,..."},{"title":"Word ladder II","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-ladder-ii","snippet":"We will first run a BFS to create the graph with adjacency list. Then we will run DFS to find all possible paths of that graph.\n\n\n\nTime Complexity: <code>O((n+m)*l)<\/code>, n is the number of words, m is number of edges(m = n^2), l is maximum word length..."},{"title":"Design circular queue","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-circular-queue","snippet":"We can implement a circular queue by using an array, the maximum size of the array will be the given input k. Then we will keep 2 pointers, one for head and one for tail, and whenever we enqueue some value, we will do it in the front, and dequeue from..."},{"title":"Distinct subsequences","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/distinct-subsequences","snippet":"We will check each character of both string, when we find a match, then we have 2 choice, either we include the current index or we skip it. If we don't have a match, we we will skip the current character. When we reached the last character of string t,..."},{"title":"Edit distance","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/edit-distance","snippet":"To compute the minimum distance, we will recursively call our decision tree. If i is 0, then we need to insert j characters, if j = 0, then we need in delete i characters. This will be our base case, If i and j position of the character matches then we..."},{"title":"Regular expression matching","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/regular-expression-matching","snippet":"We will go through our decision tree, and then we have 2 choices, either we take the * or we skip it. Based on this logic, we will create a recursive DFS solution for our problem. Then we memoize it to make it efficient.\n\n\n\nTime Complexity:..."},{"title":"Stream of characters","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/stream-of-characters","snippet":"We can use a trie to search efficiently in the stream. When we initially create our StreamChecker class, we will insert every word in reverse word. Then whenever we search for a character, we add this to a letters list, and search for the character is..."},{"title":"Substring with concatenation of all words","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/substring-with-concatenation-of-all-words","snippet":"We will create a haspmap with all the words count from the list, then we will start a sliding window, and checking the word is present in the string, then move forward by the length of each word.\n\n\n\nTime Complexity: <code>O(n*w)<\/code>, n is the number..."},{"title":"Best time to buy and sell stock with cooldown","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock-with-cooldown","snippet":"We will solve the problem with brute force using a decision tree and run DFS with that. If our index is already out of bound we return 0, this will be our base case. From there, if we are buying, then next decision will be selling or cooldown. Similarly,..."},{"title":"Interleaving string","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/interleaving-string","snippet":"We will solve the problem with brute force recursively. We will run a DFS in our decision tree, if i and j is equal to the length of s1 and s2, then we return true. Otherwise we will take either a character from s1 or a character from s2, and call our..."},{"title":"Longest common subsequence","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-common-subsequence","snippet":"We can solve the problem by brute force, we will compare each character of text1 and text2, then recursively store the longest matching sting length of these two string. Then we will use memoization to reduce the repetative work, and make it efficient...."},{"title":"Longest increasing path in a matrix","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-increasing-path-in-a-matrix","snippet":"We will run a DFS from each element of the matrix, and search from the longest increasing path. We will also memoize each repetative steps in the process, so we can solve it easily.\n\n\n\nTime Complexity: <code>O(n*m)<\/code> \nSpace Complexity:..."},{"title":"Redundant connection","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/redundant-connection","snippet":"We can use union find algorithm detect the cycle, and the edge that makes the cycle, that is our redundant edge. For union find, we will union the nodes by their rank. Initially all the rank will be 1 and each node will have the parent of themselves,..."},{"title":"Walls and gates","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/walls-and-gates","snippet":"We will run a BFS from every getes, and on the process we will replace every infinity value with the distance. Whenever we hit an obstacke, we will skip that.\n\n\n\nTime Complexity: <code>O(n*m)<\/code>, n is the number of rows and m is the number of coulmns..."},{"title":"Word ladder","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-ladder","snippet":"First we will create a adjacency list by the pattern, and the pattern will be replacing one character with <code>*<\/code>. Then we will run BFS in the graph, and count the number of iteration it takes to complete the graph, then return the value.\n\n\n\nTime..."},{"title":"Pacific atlantic water flow","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pacific-atlantic-water-flow","snippet":"We will check the top row and left coulmn for pacific ocean and right column and bottom row for atlantic ocean. Then from each position of the grid, we will check whether we can reach pacific or atlantic ocean and store it in 2 different sets. Finally,..."},{"title":"Partition equal subset sum","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-equal-subset-sum","snippet":"This is basically a 0-1 knapsack problem, for each element, either we can take the element or leave it. First, we will check, if the sum of the numbers is not even, we immediately return false. Then we calculate the target by dividing the sum by 2. Then..."},{"title":"Surrounded regions","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/surrounded-regions","snippet":"We will capture the surrounded reason by running DFS from each position and if it is not surrounded by the <code>X<\/code>, then we turn them into a temporary value <code>T<\/code>. Then after the DFS is done, we iterate over the whole grid one more time..."},{"title":"Convert sorted array to binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/convert-sorted-array-to-binary-search-tree","snippet":"If there is no element in the sorted list, then we return null. This logic we will use as our base case. Then we will select the middle of the sorted list as our root node. Then from there, all the elements if the left will go to our left subtree and all..."},{"title":"Decode ways","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/decode-ways","snippet":"We could decode a string with 1 character with just 1 way, but if we have a 2 digit string, then we can decode it 2 ways. For example, 12 can be decoded <code>1-&gt;A, b-&gt;2<\/code> or <code>L-&gt;12<\/code>. But if a string starts with 0, then we ignore..."},{"title":"Maximum product subarray","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-product-subarray","snippet":"We will keep track of minimum and maximum products of each item and keep the current maximum is our result. When the whole traversal is done, we will return the maximum result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Partition labels","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-labels","snippet":"We will first count the last position of all chacracter in a hashmap. Then we will iterate through the string, check if the last index of the chacracter is equal to the current index, if yes, then we append the current length to our result. We will..."},{"title":"Word break","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-break","snippet":"We can solve the problem using BFS. We can model the problem as graph, every index can be considered as vertex and every edge is a completed word. Then the problem just boiled down if the path exists.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Binary trees with factors","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-trees-with-factors","snippet":"We will convert the array to array set, so that we can do the lookup in constant time. Then we will check, if a candidate can divide the root without any remainder and root\/\/candidate is available in the array set, then we add it to our answer. Finally,..."},{"title":"Hand of straights","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/hand-of-straights","snippet":"We will first check if the number of card is divisible by the group size, if not, we immediately return false. Then we count the number of cards, and create a min heap with all the distinct cards. Then we pick up the top from the min heap, and check if..."},{"title":"Longest palindromic substring","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-palindromic-substring","snippet":"We will create a helper function to count the number of palindrome in a string starting from a left and right pointers. For odd number, both will be same index, for even left and right pointers will be 2 consecutive index. Then we will move forward from..."},{"title":"Merge triplets to form target triplet","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-triplets-to-form-target-triplet","snippet":"We will iterate through all the triplets and if we found any of the items are greater than the value of target triplet, we ignore it from the consideration. Then we check if we found a value which is equal to target triplet value, we will add the index..."},{"title":"Valid parenthesis string","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-parenthesis-string","snippet":"We will keep track of number of left parenthesis and number of right parenthesis in the string. For <code>*<\/code>, we could count it as left parenthesis or right parenthesis or we could ignore it. So we will keep track of maximum number of left..."},{"title":"Clone graph","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/clone-graph","snippet":"First we will create a copy of the graph and put it on our hashmap. Then we run DFS for each neighbors to do the same thing, once the whole traverse it done, we will return the copy.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Gas station","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/gas-station","snippet":"We can be greedy to solve this efficiently. First we need to check if it is possible to complete the circut by calculating the difference between total gas and total cost. If cost is higher, we immediately return -1. Else we iterate over the array, and..."},{"title":"House robber II","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/house-robber-ii","snippet":"We can calculate the house robber using the same logic as the problem House robber, but we can't take the last element as it will create a circle. So, we can actually take 2 sets of numbers, one will be from start to 1 item before last, and another set..."},{"title":"Longest increasing subsequence","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-increasing-subsequence","snippet":"First we append the first element in our list to the result array. Then we iterate over the other elements and compare, if the value is larger than the last element of the result array, if yes, then append it to the result. If not, then we find the index..."},{"title":"Palindromic substrings","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/palindromic-substrings","snippet":"We will create a helper function to count the number of palindrome in a string starting from a left and right pointers. For odd number, both will be same index, for even left and right pointers will be 2 consecutive index. Then we will move forward from..."},{"title":"Count vowels permutation","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-vowels-permutation","snippet":"We are going through the decision tree to map out all the possible combinations. The calculation will be kept in a 2-dimentional array, where each index will represent the combination of the string ended with one specific character. Finally we will mod..."},{"title":"Detect squares","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/detect-squares","snippet":"We will keep track of each elements in a list and their respective points count in a hashmap. Whenever we add a point, we increment the points count and also add the point in points list. We we calculate the count, we check it have a squares with that..."},{"title":"Find median from data stream","categories":["heap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-median-from-data-stream","snippet":"We will use a min heap and a max heap to calculate the median. The small heap will be a max heap and large heap will be a min heap. All the elements of the small heap will be smaller than large heap. So, whenever we insert something, we will insert it..."},{"title":"Insert interval","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/insert-interval","snippet":"We will go through each interval, and compare the end of the new interval with the start of the current interval, if it doesn't collide, then just insert the new interval. Else, merge the interval with the new interval and append it to the result...."},{"title":"Minimum interval to include each query","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-interval-to-include-each-query","snippet":"We will keep track of the smallest interval for each query in a min heap, so whenever we pop something from the heap, it's always the smallest number. And then we put that smallest number in our result hashmap. Finally, we will keep all the values for..."},{"title":"Multiply strings","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/multiply-strings","snippet":"We will first reverse both string and then calculate the first characters of both string, to get the digit. Then we store this digit at (i1+i2) position of our result. The (i1+i2+1) position will store the remaining value after 1st digit and (i1+i2)..."},{"title":"Non overlapping intervals","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/non-overlapping-intervals","snippet":"First we will sort the intervals. Then we will iterate through all the intervals, compare if we have any collision between 2 consecutive interval, if yes, then we will count that, then after the iteration is done, return that count.\n\n\n\nTime Complexity:..."},{"title":"Pow(x, n)","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/powx-n","snippet":"We will follow divide and conquar method to solve the problems. We we divide the n until it's a single digit, then the muliplication result is the number itself. When we merge it, we will join the numbers by multiply themselves. If the input n is..."},{"title":"Rotate image","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rotate-image","snippet":"We will save the topleft to a temporary variable and then move the bottom left to top left, then move the bottom right to bottom left and move the top right to bottom right and then finally move the temporary top left to top right. We will repeat the..."},{"title":"Set matrix zeroes","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/set-matrix-zeroes","snippet":"First we will go through the whole matrix, if we find a zero and we append it's row position to a rows to zero list and column position to columns to zero list. Then We go through each row from rows to zero and make every item 0 of that row. Same will..."},{"title":"Spiral matrix","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/spiral-matrix","snippet":"First we will determine the value of left, right, top and bottom. Then we append the top row to our result, then right column, then bottom row in reverse order and then left column in reverse order. We will continue this until we append every element of..."},{"title":"Binary tree maximum path sum","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-maximum-path-sum","snippet":"We will calculate the sum of left subtree and right subtree and return the value of maximum of them added with the current node value from our recursive DFS method. In the process we will keep track of the maximum sum of both subtree added with the..."},{"title":"Design twitter","categories":["heap","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-twitter","snippet":"This is a classic object oriented design problem. We will use a hashmap for the tweet map and another hashmap for the follow map. Each element of the tweet map with be a list, and each element of the list will have the tweetId and the count of the..."},{"title":"Kth smallest element in a bst","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-smallest-element-in-a-bst","snippet":"If we traverse the binary search tree in inorder, then we will actually get the sorted array. Then we can easily pick the kth element by picking k-1 indexed value from the array, as it's mentioned, k is 1-indexed.\n\n\n\nTime Complexity: <code>O(n)<\/code>..."},{"title":"Letter combinations of a phone number","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/letter-combinations-of-a-phone-number","snippet":"We will create a hashmap to map all the digits to the characters. The we will run backtracking to get all possible combinations of those characters and return the result.\n\n\n\nTime Complexity: <code>O(n*n!)<\/code>\nSpace Complexity: <code>O(n!)<\/code>"},{"title":"Merge k sorted lists","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-k-sorted-lists","snippet":"We can merge 2 sorted list with <code>O(n)<\/code> time complexity. Now we can go through the lists, and merge it one by one, this will be a <code>O(n^2)<\/code> operation. But if we merge every 2 list at a time and then continue the process until there is..."},{"title":"Poor pigs","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/poor-pigs","snippet":"With 2 pigs, poison killing in 15 minutes, and having 60 minutes, we can find the poison in up to 25 buckets in the following way. Arrange the buckets in a 5\u00d75 square-\n\n\n\nNow use one pig to find the row (make it drink from buckets 1, 2, 3, 4, 5, wait 15..."},{"title":"Reverse nodes in k group","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-nodes-in-k-group","snippet":"We will create a helper funtion to get the kths item of the list. Then as we go through the whole list, we will take kth item, reverse it in place and move forward till the end of the ;list.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity:..."},{"title":"Serialize and deserialize binary tree","categories":["tree","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/serialize-and-deserialize-binary-tree","snippet":"For serialize the tree, we will traverse the tree in preorder and whenever we hit a null node, we put a <code>#<\/code> character there. Then we join each character with a comma delimeter and return the string.\n\nFor deserialize the string, first we split..."},{"title":"Validate binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/validate-binary-search-tree","snippet":"We will run a DFS, and each iteration we will compare the value of the node with a left and right value, which we will pass along each iteration. For root, this values will be negative and positive infinity.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Coin change 2","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/coin-change-2","snippet":"We will first solve the problem with brute force using recursion. Then we use memoization to reduce it's complexity.\n\n\n\nTime Complexity: <code>O(n*a)<\/code>, n is the number of coins, a is the amount of money \nSpace Complexity: <code>O(n*a)<\/code>"},{"title":"Combination sum II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/combination-sum-ii","snippet":"We will run a DFS for the decision tree and use backtracking if we failed to find a result. As we are bit allowed to use the same items twice, we will keep track of the previous item, and if it is already present in the combination, we will skip it...."},{"title":"Combination sum IV","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/combination-sum-iv","snippet":"This is very similar to coin change 2. But when you take one item from the allowed list, rather start it from the same index like coin change, you should start it from the beginning of the list.\n\n\n\nTime Complexity: <code>O(n*t)<\/code>, n is the numbers..."},{"title":"Combination sum","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/combination-sum","snippet":"Basically, we have 2 ways to built the decision tree, either take the number or skip it. We are going to use backtracking to calculate the problem.\n\n\n\nTime Complexity: <code>O(2^n)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"LRU cache","categories":["linked-list","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lru-cache","snippet":"We will use a hashmap to lookup the key in out cache and a link list to keep track of most and least used cache item.\n\n\n\nTime Complexity: <code>O(1)<\/code> for each operation \nSpace Complexity: <code>O(k)<\/code>, k is the size of the cache"},{"title":"Find minimum in rotated sorted array","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-minimum-in-rotated-sorted-array","snippet":"We will start by assuming the minimum number is fisrt element of the list. Then we will do a binary search, but before calculating the mid value, we will check, if the value at left pointer is less that value of right pointer. In that case, this part of..."},{"title":"Find the duplicate number","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-the-duplicate-number","snippet":"We will use Floyd's cycle detection algorithm for solve the problem. As the input array has elements from [1, n], and there is n+1 numbers, this is nothing but a linked list, where the list starts as index 0, and the list has a cycle. We will find the..."},{"title":"Median of two sorted arrays","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/median-of-two-sorted-arrays","snippet":"We will first count the number of elements of both array and find the half. We assume the fisrt list is the longest, if not, then we swap them. Then we apply binary search to the longest list. Then we calculate left and right half for the both list. Then..."},{"title":"Mirror reflection","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/mirror-reflection","snippet":"First, think about the case p = 3 and q = 2. So, this problem can be transformed into finding m * p = n * q, where m = the number of room extension + 1, n = the number of light reflection + 1.\n\nIf the number of light reflection is odd (which means n is..."},{"title":"Search in rotated sorted array","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-in-rotated-sorted-array","snippet":"We will do a binary search, but when we devide each it to the mid pointer, we will check, if the value at left pointer is less that value of right pointer. In that case, this part of the list is already sorted. Then we do regular binary search, if not,..."},{"title":"Minimum window substring","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-window-substring","snippet":"We will first count the number of characters in the search substring. Then we create a sliding window, and move it along the whole string. If some character is missing in the sliding window, we then add more character in the string, and compare, whenever..."},{"title":"My calendar I","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/my-calendar-i","snippet":"We will create a binary search tree with all the events. If start if greater than root's end, we will insert it in right subtree, if end if less than root's start, then insert it in left subtree. If we can successfully insert an event, we return true,..."},{"title":"Sliding window maximum","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sliding-window-maximum","snippet":"We can solve this problem using monotonic increasing queue. We will add all the items from the input lust in a monotonic q and add the top of the q to our result. Then when the traverse is finished, we slice top k elements from our result and return it...."},{"title":"Find eventual safe states","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-eventual-safe-states","snippet":"This is another topological sort problem, we are using graph coloring to solve it. At first we mark(color) everything as new. When we start our traversing with DFS, we first mark it as unsafe, then we start traversing, if we find one of it's neighbor is..."},{"title":"Kth smallest element in a sorted matrix","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-smallest-element-in-a-sorted-matrix","snippet":"We will create a max heap and insert each element there. If the length of the heap is more than k, we pop item from the heap. After the iteration is done, we return to top of the heap. As python does not have max heap, we will use the min heap and..."},{"title":"Permutation in string","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/permutation-in-string","snippet":"We will first count the characters in string1 and then we will slide a window of length of string1 and count the matches of the characters of string1 and sliding window. If the number of matches is equal to the length of sliding window, that means we..."},{"title":"Add two numbers","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/add-two-numbers","snippet":"We will add first node from both list, and add it to a new list. We will also keep a carry if the number if greater than 9. We will run it until all of l1, l2 and carry is null and return the head of the new list.\n\n\n\nTime Complexity: <code>O(n)<\/code>, n..."},{"title":"Copy list with random pointer","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/copy-list-with-random-pointer","snippet":"We will traverse the whole list twice, first time we create a hashmap to store all the nodes without any linking. Then we traverse it again, but this time, as we already have all the nodes, we will just link both pointers. Then return the head of new..."},{"title":"Koko eating bananas","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/koko-eating-bananas","snippet":"We will search through each position of the piles till the largest pile, where it allows us to eat all the bananas within given h hours. We can do it in brute force, but if we search with binary search, we can reduce the time complexity in logarithmic..."},{"title":"Reorder list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reorder-list","snippet":"We will first find the middle of the list with a fast and slow pointer, fast pointer is twice as fast as the slow pointer. Then we will reverse the second half of the linked list. Finally, we merge both half.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Climbing stairs","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/climbing-stairs","snippet":"We will first solve it in recursive brute force, the use memoization to make it efficient. If the number of stairs is less than or equal to 1, then we can climb the stair with 1 step, this will be our base case. And we can take at most 2 steps, so we can..."},{"title":"Largest number at least twice of others","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-number-at-least-twice-of-others","snippet":"We will keep track of both largest and second largest number while iterating through the whole nums array. Then if the largest number is at least twice as big as the second largest, then we return the index of largest number, else we return -1.\n\n\n\nTime..."},{"title":"Min cost climbing stairs","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/min-cost-climbing-stairs","snippet":"We will follow the similar approach as Climbing stairs, first solve it with recursion, the use memoization to make it efficient. If the number of stairs is less than 0, then the cost of climbing it is also 0. As we can take atmost 2 steps at a time, then..."},{"title":"Perfect squares","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/perfect-squares","snippet":"This problem is exactly like the coin change problem. But we are not given a list of squares, we need to generate it. The biggest squares root will be the square root of the given number, without any decimal points.\n\n\n\nTime Complexity:..."},{"title":"reverse-integer","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-integer","snippet":"We can get the least significant digit by moding it with 10. Then we can also get the remainder of the number by divide it by 10. The only catch of this problem is if the reversed number overflows 32 bit integer value. We will check if the result at any..."},{"title":"Sum of two integers","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/sum-of-two-integers","snippet":"We know, <code>2^a + 2^b = 2^(a+b)<\/code> and <code>log2(2^a) = a<\/code>. We can use this two formula to sum 2 numbers without using <code>+<\/code>.\n\n\n\nTime Complexity: <code>O(1)<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Car fleet","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/car-fleet","snippet":"First we will create a pair with position and speed, and sort it by the position. Then we start at the position which is closer to the target. Then we will calculate how much time it's needed to reach the target by this formula,..."},{"title":"Daily temperatures","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/daily-temperatures","snippet":"We will initialize the result array and assign zero to each elements. We will iterate through the temperatures, and if the stack is empty or stack top value is less that the current temperature, then we will push the temperature and the index in our..."},{"title":"Largest rectangle in histogram","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/largest-rectangle-in-histogram","snippet":"First we go through all the heights in a loop. We also keep a stack to calculate max area. If stack is empty, then we push the height along with the index it sits on. Then we check whether the height is less than the top of the stack. If yes, we pop it..."},{"title":"Top k frequent words","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/top-k-frequent-words","snippet":"First we will count all the words and then create a max heap with the count, each element will have 2 items, first will be the count, second will be the word itself. Then we pop k elements and put the words in a list and return it.\n\n\n\nTime Complexity:..."},{"title":"Word search II","categories":["trie"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-srarch-ii","snippet":"The problem is an extension of the problem word search. We will run backtracking DFS to find the word. But as there are multiple word to search from, we will use a trie data structure, so we can search quickly. Whenever we found a word, we add it to our..."},{"title":"Word subsets","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-subsets","snippet":"First we count all the characters in our search array and combine it to a hashmap containing all the characters count. Then we iterate through each word in our input word list, count all the characters and then compare if we have every characters count..."},{"title":"Find and replace pattern","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-and-replace-pattern","snippet":"We will create a hashmap for each word counting the length of the hashmap at that position. Then we create the same hashmap for our pattern. Then we iterate over each word, match it with the pattern and return the matched value as an array.\n\n\n\nTime..."},{"title":"Generate parentheses","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/generate-parentheses","snippet":"We will solve it with backtracking. We will add one open parentheses, then call the recusive backtracking method. If the number of opening parentheses and closing parentheses are equal to input, that means we get our solution, we append it to our result...."},{"title":"Longest consecutive sequence","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-consecutive-sequence","snippet":"We will first create a set with the input numbers, so we can look up in the set with constant time. Then we iterate over the numbers, check if the current number has any predecisior, if not that means it's a start of a sequence. Then we look forward for..."},{"title":"Longest repeating character replacement","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-repeating-character-replacement","snippet":"We will take a sliding window to solve this problem. We will take a left and right pointer, initially both will be at 0-th index. Then we move our right pointer and count the number of occurances, store it in a hashmap. We will also keep track of the..."},{"title":"Search suggestions system","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-suggestions-system","snippet":"First we will sort the products list. We will go through each character, create a search substring and then check if the product from the products list starts with the search substring. If yes, we add it to the suggestions, and when the suggestions..."},{"title":"Happy number","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/happy-number","snippet":"We will calculate the next number, and memoize it. If it's already in the memo, that means we have a cycle, then we return false. Otherwise the number will end up on to be 1. Then we break the loop and return true.\n\n\n\nTime Complexity: <code>O(n)<\/code>..."},{"title":"Min cost to connect all points","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/min-cost-to-connect-all-points","snippet":"We will first create an adjacency list from the given points, in the adjacency list we will also keep the manhattan distance that is mentioned in the problem. After creating the adjacency list, it's basically applying Prim's algorithm to get the minimum..."},{"title":"Palindrome partitioning","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/palindrome-partitioning","snippet":"We will solve it through backtracking. We will check every possible substring, if it is palindrome, then we add it to the partition, when we are at the end of the string, we add it to the result. We will run it for every possible solution, and then..."},{"title":"reconstruct-itinerary","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reconstruct-itinerary","snippet":"Fisrt we will sort our input tickets, so that when we create the adjacency list from it, it will already be sorted. Then we run DFS with backtrack, as it's possile that we go though one edge, but it's not possile to visit all the nodes. When we traverse..."},{"title":"Swim in rising water","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/swim-in-rising-water","snippet":"We will apply Dijkstra's greedy algorithm to solve this problem. It's basically a BFS traversal, but rather than use a regular queue, we will use a minimum heap aka. priority queue to pop from the queue. In the process we will store the maximum value of..."},{"title":"Flatten binary tree to linked list","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/flatten-binary-tree-to-linked-list","snippet":"We will recursive move all the preorder traversal nodes to inorder. We keep track of previous node in very recursive call, move the right right subtree to a temporary variable, flatten the left subtree, move it to the right subtree to the left subtree,..."},{"title":"Alien dictionary","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/alien-dictionary","snippet":"We will first create an adjacency list from our input array. If 2 array has a different first charcter, then word1[0] should be arreared before word2[0]. When the grph is already created, we can then do a topological sort on the adjacency list. we will..."},{"title":"Cheapest flights within k stops","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/cheapest-flights-within-k-stops","snippet":"We will solve the problem using Bellman-Ford algorithm. Initially we will assign infinity prices to all nodes except the source nodes price will be 0. We will basically run the BFS for k+1 steps as we are allowed to take k stops. In the process we will..."},{"title":"Count good nodes in binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/count-good-nodes-in-binary-tree","snippet":"We will traverse the tree with DFS and in the process we check if the value of the node is greater than or equals to it's child nodes. If wes, then we count it. After the traverse is done, we return the count.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Lowest common ancestor of a binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lowest-common-ancestor-of-a-binary-tree","snippet":"We check if p or q are equal to root, then we return root as we are guranteed to have a common ansestor. If not then we recursively call the function for both left and right subtree. If we found both, then root is our answer, else left or right is our..."},{"title":"Network delay time","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/network-delay-time","snippet":"We will use Dijkstra's shortest path algorithm to solve this problem. First we will create an adjacency list from the edge list, where the key will be the source node and value will be a tuple contain both destination and weight. Then we create a min..."},{"title":"Verifying an alien dictionary","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/verifying-an-alien-dictionary","snippet":"This is actually a subproblem of alien dictionary. First we will create a function for checking lexical order of 2 words based on the input order. We will go through each characters of the words, and check whether it matches with the given order string...."},{"title":"Brust balloons","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/burst-balloons","snippet":"Fist we will add 1 in either side of the input list to tackle terminal edges. We will create a decision tree, the base case will be if we brust the element last, then the coin would be the balloon itself multiple by 2 consicutive element. Then we..."},{"title":"Find first and last position of element in sorted array","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-first-and-last-position-of-element-in-sorted-array","snippet":"We will first do a regular binary search to get the position of the target. Then we expand both ways to get the left and right position of the target and return that. If we can't find the target we return [-1, -1].\n\n\n\nTime Complexity:..."},{"title":"Trapping rain water","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/trapping-rain-water","snippet":"We will iterate over the whole list, and also check the left and right side for the highest value, then substruct the value itself from the highest value, ans add it to a running sum. Then we return the result after the iteration is over.\n\n\n\nTime..."},{"title":"Implement queue using stacks","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/implement-queue-using-stacks","snippet":"We will have 2 stack, one for input, one for output. Whenever we push anything, we push it to the input stack, then pop every element from input stack and push it back to output stack. Every other operation we do it in output stack.\n\n\n\nTime complexity..."},{"title":"Longest substring without repeating characters","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/longest-substring-without-repeating-characters","snippet":"We will use a set to keep track of repeating characters. We will have 2 pointers, we will move our right pointer, check if the character as right pointer is already exist in the set, if exists, then we remove characters for left until the character is..."},{"title":"Permutations II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/permutations-ii","snippet":"First we will count the number of each element, then we create our decision tree, if we take one element, then we remove that element form our count hashmap. If it has multiple instance, we reduce it's count by 1. We will take every element and that will..."},{"title":"Permutations","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/permutations","snippet":"We will solve it recursively using backtracking. If there is only one element in the list, permutations of this will return the same list. This will be our base case. If it has 2 elements, we remove one, so it fall into base case, then add the left..."},{"title":"Search a 2d matrix II","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-a-2d-matrix-ii","snippet":"if the current grid value matrix[r][c] is less than the target, that means, we don't need to search in this row anymore, as all the values are already bigger than the matrix[r][c]. If the value is greater than the target, then we move the column position..."},{"title":"Search a 2d matrix","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/search-a-2d-matrix","snippet":"We can just consider the matrix as a linear sorted array. Then if we need an element number i in our flattened list, we can get it by matrix[i\/\/col][i%col]. Then we can do a regular binary search on our flattened matrix.\n\n\n\nTime Complexity:..."},{"title":"Subsets II","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/subsets-ii","snippet":"We will first sort the element. Then like the original subset problem, we will have 2 choice for each element, either choose it or skip it. As we don't want duplicate subset, we will skip the same character from the list.\n\n\n\nTime Complexity:..."},{"title":"Word search","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/word-search","snippet":"We will run dfs on each element of the board, if we find a character match, then we move forward and search for next character in all 4 directions.\n\n\n\nTime Complexity: <code>O(n*m*4^n)<\/code> \nSpace Complexity: <code>O(n*m)<\/code>"},{"title":"3Sum","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/3sum","snippet":"If you already solved the 2 sum ii problem, you might get the idea. First we will sort the list. Then we take the first element at first position, then for the rest of the elements we take 2 pointers, and then solve it like 2 sum. When we found a..."},{"title":"Design add and search words data structure","categories":["trie","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/design-add-and-search-words-data-structure","snippet":"We will implement the trie as normal, the addWord function will be identical to a normal trie. The search function will be a little different. We will iterate over each character, if the character is a normal alphabet, we will do it as it is. But if it..."},{"title":"K closest points to origin","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/k-closest-points-to-origin","snippet":"First we will calculate all the distances from the origin and put that on a list. Then we heapify that list, then pop top k elements and put their coordinate on a result array and return that.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace..."},{"title":"Kth largest element in an array","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-largest-element-in-an-array","snippet":"We can just sort the element and return second largest element from the array, but it will have <code>O(nlog(n))<\/code> time complexity. But if we use a heap, then the time complexity will be <code>O(n)<\/code> for heapify and then <code>O(log(n))<\/code>..."},{"title":"Last stone weight","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/last-stone-weight","snippet":"We will use a max heap and then pop 2 element at a time and simulate the problem statement. As python doesn't have any max heap, we will use the min heap but multiply each element with -1 and the the whole simulation is done we will get the absolute..."},{"title":"Meeting rooms II","categories":["intervals","heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/meeting-rooms-ii","snippet":"We will sort the intervals, then in each iteration we will compare the end of the meeting with the start of the previous meeting. We will keep track of the count for the number of meeting going on, and another running counter to keep track of the max..."},{"title":"Plus one","categories":["math-and-geometry"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/plus-one","snippet":"First we reverse the list, then add one to the fist item, if the number is 9, then we keep a carry and add it to the next number. We will do that until all the digit in the list have been iterated through. Then we return the reversed list.\n\n\n\nTime..."},{"title":"Remove nth node from end of list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/remove-nth-node-from-end-of-list","snippet":"We will have 2 pointer, first we move the right pointer to nth node. Then we move both left and right pointer until the right pointer moves to the end of the list, that means left pointer is now on nth node from the end. Then we remove the node and..."},{"title":"Subsets","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/subsets","snippet":"We will do backtracking to solve the result. For each element of the list, we have 2 option, either we take the element or we leave the element. From this base case, if we run dfs for from the beginning, we will get all the subsets for the list.\n\n\n\nTime..."},{"title":"Task scheduler","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/task-scheduler","snippet":"We will first count each characters and create a max heap out of it. Then we pop the item from the heap, put it on a queue, and increase the value of our counter. Then we process the task, if there is still task remaining for the same type, we push it..."},{"title":"Time based key value store","categories":["binary-search","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/time-based-key-value-store","snippet":"We will keep a hashmap as the key value store, key will be used as the key, value will have an array storing all the values and timestamp. When we search for the value, we will look up in the store for the values and binary search through the timestamp..."},{"title":"Jump game II","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/jump-game-ii","snippet":"This is very similar to jump game, we will go for a greedy approah. We will have 2 pointer, left and right to determine the level of each move. In every iteration we will calculate the maximum number of moves on level have and then move our left and..."},{"title":"Jump game","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/jump-game","snippet":"This problem could definitely be solved by dynamic programming, but if we take greedy approach, we can solve it in linear time. We can iterate through the array from last index to first index. We set our initial goal to the last index value. If the sum..."},{"title":"N-queens","categories":["backtracking"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-queens","snippet":"We will have 3 different sets, one for the column, one for positive diagonal and one for negative diagonal. We will iterate over the each row, and try to add the queen in the board. If this is already in either of the 3 sets, then we continue to the next..."},{"title":"Partition list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/partition-list","snippet":"We will have 2 separate linked list, left and right. All the values that is less than target will go to the left list, all the values that is greater than or equal to target will go to the right list. Finally we will merge both and return.\n\n\n\nTime..."},{"title":"Fibonacci number","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/fibonacci-number","snippet":"This is the classing fibonacci number problem. First we solve this using recursion, then we memoize it to increase efficiency.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Graph valid tree","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/graph-valid-tree","snippet":"First we create a adjacency list from the edge list. Then we traverse the whole graph starting from node 0. If we don't have any cycle or any disjoint node, then it's a valid tree, otherwise we return False.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace..."},{"title":"Implement stack using queues","categories":["queue","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/implement-stack-using-queues","snippet":"It's easy to implement a stack using queue. You can pop, peek and check the empty as you normally do in a queue. You just need to do some extra work during the push method. First you push it to the queue, then you pop every element of the queue except..."},{"title":"Implement trie prefix tree","categories":["trie","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/implement-trie-prefix-tree","snippet":"This problem literary ask to implement a prefix tree or Trie. Each node will have children for which we have used a hashmap for constant time insert and lookup abd a boolean value to denote whether it's the end of the word or not.\n\n\n\nTime Complexity:..."},{"title":"Maximum subarray","categories":["greedy"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-subarray","snippet":"We will have 2 running count, one is for our result and one is for the total of the array. First we assume first element of the input is out result. Then we iterate through the input and calculate total. If total if bigger than our result, we replace..."},{"title":"Meeting rooms","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/meeting-rooms","snippet":"We will sort the given array based on start time. Then we can compare, if the end of first meeting is before the start of last meeting, if yes return False, else return True.\n\n\n\nTime Complexity: <code>O(nlog(n))<\/code> \nSpace Complexity: <code>O(1)<\/code>"},{"title":"Merge intervals","categories":["intervals"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-intervals","snippet":"First we sort the intervals with the start key. Then we append the first item on the output list. Then we will iterate over all intervals and compare the last end with the current start, if the last end is bigger than the current start, then we merge..."},{"title":"Binary tree inorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-inorder-traversal","snippet":"We will traverse the tree with recursive DFS, as it is inorder traversal, we first traverse the left subtree then append the root, and lastly we traverse the right subtree.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Binary tree postorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-postorder-traversal","snippet":"We will traverse the tree with recursive DFS, as it is postorder traversal, we first traverse the left subtree, the the right subtree and then append the root to our result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Binary tree preorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-preorder-traversal","snippet":"We will traverse the tree with recursive DFS, as it is preorder traversal, we first append the root, then the left subtree and then right subtree.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Kth largest element in a stream","categories":["heap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/kth-largest-element-in-a-stream","snippet":"We will create a min heap from the elements of the stream. We will make sure heap size is always k. That means the smallest element will ve at the heap's top and the largest element will be at the 0th index. Then we can return the 0th index of the heap..."},{"title":"N-ary tree postorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-ary-tree-postorder-traversal","snippet":"We will traverse the tree with recursive DFS, as it is postorder traversal, we first traverse all the children and then append the root to our result.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"N-ary tree preorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/n-ary-tree-preorder-traversal","snippet":"We will traverse the tree with recursive DFS, as it is preorder traversal, we first append the root to our result and then traverse all the children.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Binary search","categories":["binary-search"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-search","snippet":"The problem itself is called binary search, all we need to do a classic binary search. We will choose a mid, if the target value is greater than the mid value, we move our left pointer to mid or if the target is lesser that the mid value, then we move..."},{"title":"Evaluate reverse polish notation","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/evaluate-reverse-polish-notation","snippet":"We can go through each character and put this on a stack. When we find any arithmetic symbol, we pop last 2 element for the stack, do the operation and push back the value to the stack. After the iteration is over, we will have only one value left in our..."},{"title":"Linked list cycle","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/linked-list-cycle","snippet":"We will take two pointer, fast and slow. Fast goes twice as fast as slow. Then we run both pointers at the same time, if there is a cycle, then this two pointers will meet, else we will goes to the last pointer and return false.\n\n\n\nTime Complexity:..."},{"title":"Min stack","categories":["stack","design"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/min-stack","snippet":"We we have 2 stack. One will be the regular and the another will be min stack. When we push something in stack, we push the value in regular stack and we check the top element of the min stack. If top value is less than the value, then we push the top..."},{"title":"Pascals triangle","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/pascals-triangle","snippet":"We know n level pascals triangle will have n level. We will start with level 1, we put 1 there. Then we will start a loop from level 2 to level n. Then we fill up the whole level with 1. Then we loop thorugh from second element to second last element and..."},{"title":"Path sum","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/path-sum","snippet":"We can run DFS from root to leaf and calculate whether the target is equal to the sum of all nodes. We can do it recursively. Our base case will be if the node is empty, then we will return false and if the node is a leaf node, we will check the value is..."},{"title":"Encode and decode string","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/encode-and-decode-string","snippet":"We will join the array using <code>$$<\/code> as delimeter, and also split the string with <code>$$<\/code> to get it back.\n\n\n\nTime Complexity: O(n), where n is the length of the array \nSpace Complexity: O(1)"},{"title":"Find largest value in each tree row","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/find-largest-value-in-each-tree-row","snippet":"This is a classic BFS problem. We will traverse the tree with BFS and we will find the maximum value in each level. After each level is done, we will push the max value in our result array. After the traversal is done, we will return the result.\n\n\n\nTime..."},{"title":"Lowest common ancestor of a binary search tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/lowest-common-ancestor-of-a-binary-search-tree","snippet":"We are guranteed to find a common ansestor. That means if the 2 values of p and q have their value both on left side or the tree root, right side of the tree root or opposite side of tree root. As it's a binary search tree, that means if both of the..."},{"title":"Minimum path sum","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/minimum-path-sum","snippet":"We will first solve it with brute force using recursion and then use memoization to make it efficient. For recursion, we can think about the base case, if our current position is out of bound, then we return infinity, if we are at the end block, then..."},{"title":"Best time to buy and sell stock","categories":["sliding-window"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/best-time-to-buy-and-sell-stock","snippet":"This is a classic sliding window problem. We will take 2 pointers, left pointer at the first element and right pointer as the second element. Then we forward right pointer and compare if the value at right pointer is less than the left pointer, then we..."},{"title":"Coin change","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/coin-change","snippet":"This is a classing dynamic programming problem. First we will solve it in brute force and then memoization(top-down) to reduce complexity.\n\n\n\nTime Complexity: <code>O(n*a)<\/code>, n is the number of coins, a is the amount of money \nSpace Complexity:..."},{"title":"House robber","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/house-robber","snippet":"We will first solve this with brute force and then use memoization to optimize our solution. For this problem, if we have no item, then the sum would be zero, so it would be our base case, we have 2 options for our recursive call, either we include the..."},{"title":"Target sum","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/target-sum","snippet":"We will first solve it with brute force using recursion and then use memoization to make it efficient. For recursion, we can think about the base case, we will start our index at the number of element of the given array, and when our index is less then..."},{"title":"Unique paths","categories":["dynamic-programming"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/unique-paths","snippet":"We will first solve it with brute force using recursion and then use memoization to make it efficient. For recursion, we can think about the base case, if our current position is out of bound, then we return 0, if we are at the end block, then there is..."},{"title":"Number of 1 bits","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/counting-bits","snippet":"We can have a repeatative pattern if we look at the most significant bit. For example, lets look the following table-\n\n\n\n\n  Number\n  Binary\n\n\n\n\n  0\n  000\n\n\n  1\n  001\n\n\n  2\n  010\n\n\n  3\n  011\n\n\n  4\n  100\n\n\n  5\n  101\n\n\n  6\n  110\n\n\n  7\n  111\n\n\n\n\nFor first 2..."},{"title":"Course schedule II","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/course-schedule-ii","snippet":"This is a classing cycle detect graph problem. We will first convert our edge list to adjacency list. Then we use white-grey-black algorithm to detect cycle. At first every node will be in our white list. When we start traversing using DFS, we mark the..."},{"title":"Course schedule","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/course-schedule","snippet":"This is a classing cycle detect graph problem. We will first convert our edge list to adjacency list. Then we use white-grey-black algorithm to detect cycle. At first every node will be in our white list. When we start traversing using DFS, we mark the..."},{"title":"Missing number","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/missing-number","snippet":"We can XOR the same number to even it out, for example 3^3 or 5^5 will always be 0. That means we can XOR every number form 1 to number of element in our input array and then XOR the input numbers with it. That will even our every number except the..."},{"title":"Reverse bits","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-bits","snippet":"We can iterate over all 32 bits of our given number, then put it on the opposite bit or our result. If we take i-th bit, we will put it in the (31-i)th bit of our result.\n\n\n\nTime Complexity: O(1), as we always iterate 32 times. \nSpace Complexity: O(1)"},{"title":"Valid parentheses","categories":["stack"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-parentheses","snippet":"We can iterate over each characters of the string, and if it's a opening braket, we push it to the stack. If not, then we check, if it matches the top of the stack braket. If matches then we pop it from the stack, otherwise we immediately return false...."},{"title":"Container with most water","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/container-with-most-water","snippet":"We will take two pointers, one at the beginning and another at the end. Then we calculate the water in between by taking the min value of this 2 position and multiply by the difference of these pointers. We will keep a running max result. Then we move..."},{"title":"Merge two sorted list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/merge-two-sorted-lists","snippet":"This approach is very much like merge sort. We took 2 pointers for 2 list, compare thier values, and assign the smaller one to our new list. Then we move that pointer to next node. We go through the process until one list is empty. Then we attach the..."},{"title":"Reverse linked list","categories":["linked-list"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/reverse-linked-list","snippet":"We start with a null node called previous, iterate through the list, and move it's next printer previous on and then repeat it till the end. Then we just return the previous which is not the current head of the list.\n\n\n\nTime Complexity: <code>O(n)<\/code>..."},{"title":"Balanced binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/balanced-binary-tree","snippet":"We will traverse the tree with DFS and also keep track of the depth. Then return both the balanced and depth from our DFS recursion. Then we just compare whether the difference between the left and right subtree is not more than 1.\n\n\n\nTime Complexity:..."},{"title":"Construct binary tree from preorder and inorder traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/construct-binary-tree-from-preorder-and-inorder-traversal","snippet":"The first element of the preorder traversal is always the root. So, if we know the root, we can then find the left and right sub tree from inorder traversal. We will then create the tree recursively form this 2 traversal. As the members of the tree are..."},{"title":"Diameter of binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/diameter-of-binary-tree","snippet":"We can calculate the depth of a subtree with DFS. Then we add both subtree and store it in our running answer. After the whole tree traversal is done, we return our running answer.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Invert binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/invert-binary-tree","snippet":"We can take the left subtree and right subtree and swap their position. We will do it recursively for every subtree.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Maximum depth of binary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-depth-of-binary-tree","snippet":"We will traverse the tree with DFS and keep a counter to keep track of every level. Then we will take the maximum from both subtree and return the counter.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Maximum depth of n-ary tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/maximum-depth-of-n-ary-tree","snippet":"We will traverse the tree with DFS and keep a counter to keep track of every level. Then we will take the maximum from all of those level and return the counter.\n\n\n\nTime Complexity: <code>O(n)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Same tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/same-tree","snippet":"We can traverse through the whole tree and compare each value. We are doing it with DFS for this solution.\n\n\n\nWe are traversing the thee once, so time complexity is <code>O(n)<\/code>. The call stack of the recursion can store the whole tree in worst case..."},{"title":"Subtree of another tree","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/subtree-of-another-tree","snippet":"We can check whether two tree are same using the same logic from Same tree problem. Then we will check recursively for every subtree whether that is same as out target subtree.\n\n\n\nTime Complexity: <code>O(n^2)<\/code> \nSpace Complexity: <code>O(n)<\/code>"},{"title":"Two sum II - input array is sorted","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/two-sum-ii-input-array-is-sorted","snippet":"As the array is sorted, we will take 2 pointer at the beginning and the end. If the sum of two numbers are equal to target, we return. If the sum is bigger than target, that means we need a smaller number for the sum, so we move the end pointer,..."},{"title":"Binary tree level order traversal","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-level-order-traversal","snippet":"This is a classing BFS problem. We should traverse the whole tree with BFS, and store the values level by level to a list. Then combine each level to a list and return.\n\n\n\nThis is very efficient. Both the time and space complexity of this problem is..."},{"title":"Number of 1 bits","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/number-of-1-bits","snippet":"We can logical and any number with 1 to check whether the last bit of that number is 1 or 0. We can also check this by checking the number is odd or even. Odd numbers always has last bit as 1. We count that bit and then write shift the number 1 bit to..."},{"title":"Product of array except self","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/product-of-array-except-self","snippet":"We can go thorugh the whole list once and caculate and store the multiplicatio of prefix indeies in the result array directly. That way we don't use any extra memory. Then we do the same thing but in reverse order. And instead of calculating the prefix..."},{"title":"Single number","categories":["bit-manipulation"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/single-number","snippet":"We can iterate through the entire array and XOR everything. For starter we start our result to 0, as it has no effect on our XOR operation. If we XOR the same numbers, it turns into 0. So, every pair will turn into 0, except the single number.\n\n\n\nTime..."},{"title":"Valid palindrome","categories":["two-pointers"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-palindrome","snippet":"We will take 2 pointers, at the beginning of the string and end of the string, then we compare both. If the character is not an aplhabet or number we move the pointer value by one. We also convert the whole string to lowercase before doing the..."},{"title":"Valid sudoku","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-sudoku","snippet":"We can use 3 hashmap to store the values of rows, colums and square. For rows and columns hashmap we will use the row and column number as key. For square hashmap, we can use the integer division of the row, column value by 3, and use the set as key. For..."},{"title":"Group anagrams","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/group-anagrams","snippet":"We are given a list of strings. We can iterate through each string, and sort it charactes, then use this as key in a hashmap, and the value of the hashmap will be a list. We will append the original string to the list. That what, each anagram will have..."},{"title":"Rotting oranges","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/rotting-oranges","snippet":"This is a BFS problem. We have to count the number of steps as minutes to return. If we can't traverse the whole grid, then we will return -1. Only tricky part is we can have multiple rotten oranges in the grid at the very beginning. So, we can go..."},{"title":"Top k frequent element","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/top-k-frequent-elements","snippet":"We will count the frequency of each element and store it in a hashmap, where the number itself will be the key and frequency will be the value. Then we sort the elements of the hashmap and get the keys as a list. Then we return first k elements of the..."},{"title":"Valid anagram","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/valid-anagram","snippet":"We can split both string to characters, sort and then compare each characters at every position. If we don't find any match, we return False. After comparing every character, we will return True.\n\n\n\nFor sorting we have complexity <code>O(nlog(n))<\/code>,..."},{"title":"Binary tree right side view","categories":["tree"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/binary-tree-right-side-view","snippet":"This problem asked us to return the list of the nodes when we look it from the right side. That means, if we traverse the whole tree with BFS, we will see the right side node of the tree in each level. So we can just traverse the tree with BFS and at the..."},{"title":"Max area of island","categories":["graph"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/max-area-of-island","snippet":"This is a classing grid graph problem. We will iterate through each row and column, when we find a new land, we will then expand the area of land sorrounding. We can use BFS or DFS to do that. I will go with DFS as it's a bit easier to write. Then we..."},{"title":"Contains duplicate","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/contains-duplicate","snippet":"We are given a list of integers. We have to find out whether we have any duplicate or not. We can store the elements in a hashset while iterating through the list. We the item is already present in the hashset then we immediately return <code>true<\/code>..."},{"title":"Two sum","categories":["array-and-hashmap"],"link":"https:\/\/one-problem-a-day.milon.im\/problems\/two-sum","snippet":"This problem has very clear statement. It will have a list of integer and a target integer. We should return the 2 indeces of the numbers that adds up to the target. It is guranteed that we will have a solution and it would be unique.\n\nWe can just..."}]